# [Pág. 61] Capítulo 03 - Administrando Usuarios

Algunos conceptos a conocer:

- **UserDetails**, describe al usuario de Spring Security.
- **GrantedAuthority**, nos permite definir acciones que el usuario puede ejecutar.
- **UserDetailsManager**, que **extiende** el contrato de **UserDetailsService**. Más allá del comportamiento heredado,
  también describe acciones como crear un usuario y modificar o eliminar la contraseña de un usuario.

## [Pág. 62] Implementando la autenticación en Spring Security

Como parte de la gestión de usuarios, utilizamos las interfaces **UserDetailsService y UserDetailsManager**.

- El **UserDetailsService**, solo es responsable de recuperar el usuario **byUsername()**.
- El **UserDetailsManager**, agrega un comportamiento que se refiere a *agregar, modificar o eliminar el usuario*.

La separación entre los dos contratos (interfaces) es un excelente ejemplo del principio de
Segregación de interfaces. Si la aplicación solo necesita autenticar a los usuarios, implementar el
contrato **UserDetailsService** es suficiente para cubrir la funcionalidad deseada.

## [Pág. 65] Describiendo el usuario

Para Spring Security, una definición de Usuario debe respetar el contrato **UserDetails**.

La interfaz **UserDetails** ``representa al usuario tal como lo entiende Spring Security``. La clase de tu
aplicación que describe al usuario tiene que implementar esta interfaz, de esta forma el framework lo entenderá.

## [Pág. 66] Detalles de la interfaz GrantedAuthority

Las **authorities** representan lo que el usuario puede hacer en su aplicación. Para describir las
autoridades en Spring Security, utilice la interfaz **GrantedAuthority**.

Aquí está la implementación de la Definición de GrantedAuthority:

````
public interface GrantedAuthority extends Serializable {
    String getAuthority();
}
````

Implementaremos el método **getAuthority()** de la interfaz **GrantedAuthority** usando la clase
**SimpleGrantedAuthority** que nos permitirá crear instancias de authority.

````
GrantedAuthority g = new SimpleGrantedAuthority("READ");
````

La clase SimpleGrantedAuthority ofrece una forma de crear instancias inmutables del tipo GrantedAuthority. Proporcione
el nombre de la autoridad al crear la instancia.

## [Pág. 71] Combinando múltiples responsabilidades relacionadas con el Usuario

Normalmente en una aplicación tenemos usuarios que están **mapeados a una tabla de una base de datos** por lo que
**necesitamos una clase (Entity)** que represente la entidad de persistencia y luego están los **usuarios que maneja la
misma aplicación (UserDetails: usuario de Spring Security)**.

**Entidad que representa un usuario de una BD o una representación de un Usuario proveniente de un Servicio Web**

````
public class User {
    private Long id;
    private String username;
    private String password;
    private String authority; // Por el momento solo trabajaremos con un authoriy por usuario
    
    /* setters, getters, toString */
}
````

**Nota**

> Por el momento no estamos usando las dependencias de Spring Data JPA para representar con anotaciones
> la Entity User, pero digamos que recuperamos usuarios a través de un servicio web desde otro sistema, y necesitamos
> una clase que nos permita representar las instancias de usuario. Entonces, la clase creada anteriormente
> nos representará una Entity o como en este caso, simplemente una clase que nos representará instancias
> de un usuario proveniente de un Servicio Web.

**Usuario reconocido por Spring Security**

````
public class SecurityUser implements UserDetails {
    private final User user;

    public SecurityUser(User user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority(this.user.getAuthority()));
    }

    @Override
    public String getPassword() {
        return this.user.getPassword();
    }

    @Override
    public String getUsername() {
        return this.user.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}
````

Esta clase representa un usuario con el que Spring Security trabajará dentro de su Arquitectura, ya que implementa la
interfaz UserDetails. Observamos que esta clase que implementa el UserDetails usa la clase Entity User para obtener los
datos que dicha entidad trae desde la base de datos (o de un servicio web), pero es esta implementación (SecurityUser)
la clase que Spring Security reconocerá como un usuario de Spring, para manejar sus roles, permisos, autenticación, etc.

**NOTA**
> Puede encontrar diferentes enfoques para separar las dos responsabilidades.
> No quiero decir que el enfoque que presento en esta sección sea el mejor o el único. Por lo general, la forma en que
> elige implementar el diseño de la clase varía mucho de un caso a otro. Pero la idea principal es la misma: **evite
> mezclar responsabilidades e intente escribir su código lo más desacoplado posible para aumentar la capacidad de
> mantenimiento de su aplicación.**