# [Pág. 195] Capítulo 09 - Implementando filtros

En los capítulos anteriores aprendimos sobre un componente que llamamos **Authentication Filter**, que delega la
responsabilidad de autenticación al Authentication Manager. También aprendió que cierto filtro se encarga de la
configuración de la autorización después de una autenticación exitosa.

En Spring Security, en general, los filtros HTTP gestionan cada responsabilidad que se debe aplicar a la solicitud. Los
filtros forman una cadena de responsabilidades. **Un filtro recibe una solicitud, ejecuta su lógica y, finalmente,
delega la solicitud al siguiente filtro de la cadena.**

![Filters](./assets/Filters.png)

En la práctica, las aplicaciones vienen con varios requisitos, donde el uso de configuraciones predeterminadas ya no
funciona. Deberá agregar o reemplazar los componentes existentes de la cadena. **Con la implementación predeterminada,
utiliza el método de autenticación HTTP basic, que le permite confiar en un nombre de usuario y una contraseña.** Pero
en escenarios prácticos, hay muchas situaciones en las que necesitará más que esto. **Tal vez necesite implementar una
estrategia diferente para la autenticación,** notificar a un sistema externo sobre un evento de autorización o
simplemente registrar una autenticación exitosa o fallida que luego se usa en el seguimiento y la auditoría (figura
9.3). Sea cual sea su escenario, **Spring Security le ofrece la flexibilidad de modelar la cadena de filtros exactamente
como lo necesita.**

Figura 9.3 Puede personalizar la cadena de filtros agregando nuevos filtros antes, después o en la posición de los
existentes. De esta manera, puede personalizar la autenticación, así como todo el proceso aplicado a la solicitud y
respuesta.

![Customer-filter](./assets/Customer-filter.png)

## Implementando filtros en la arquitectura Spring Security

Aprendió en los capítulos anteriores que el filtro de autenticación intercepta la solicitud y delega la responsabilidad
de autenticación al administrador de autenticación. Si queremos ejecutar cierta lógica antes de la autenticación, lo
hacemos insertando un filtro antes del filtro de autenticación.

Los filtros en la arquitectura de Spring Security son filtros HTTP típicos. **Podemos crear filtros implementando la
interfaz Filter del paquete javax.servlet.** En cuanto a cualquier otro filtro HTTP, **debe anular el método
doFilter()** para implementar su lógica. Este método recibe como parámetros ServletRequest, ServletResponse y
FilterChain:

- **ServletRequest**: representa la solicitud HTTP. Usamos el objeto ServletRequest para recuperar detalles sobre la
  solicitud.
- **ServletResponse**: representa la respuesta HTTP. Usamos el objeto ServletResponse para modificar la respuesta antes
  de enviarla al cliente o más adelante en la cadena de filtrado.
- **FilterChain**: representa la cadena de filtros. Usamos el objeto FilterChain para reenviar la solicitud al siguiente
  filtro de la cadena.

La cadena de filtros representa una colección de filtros **con un orden definido** en el que actúan.

Spring Security nos proporciona algunas implementaciones de filtros y su orden. Entre los filtros provistos:

- **BasicAuthenticationFilter**: Se encarga de la autenticación HTTP Basic, si está presente.
- **CsrfFilter**: se ocupa de la protección contra la falsificación de solicitudes entre sitios (CSRF), de la que
  hablaremos en el capítulo 10.
- **CorsFilter**: se encarga de las reglas de autorización de uso compartido de recursos de origen cruzado (CORS), que
  también analizaremos en el capítulo 10.

No necesita conocer todos los filtros, ya que probablemente no los tocará directamente desde su código, pero **sí debe
comprender cómo funciona la cadena de filtros y estar al tanto de algunas implementaciones.** En este libro, solo
explico aquellos filtros que son esenciales para los diversos temas que discutimos.

Es importante comprender que una aplicación no necesariamente tiene instancias de todos estos filtros en la cadena. La
cadena es más larga o más corta dependiendo de cómo configure la aplicación. Por ejemplo, en los capítulos 2 y 3,
aprendió que debe **llamar al método httpBasic() de la clase HttpSecurity si desea utilizar el método de autenticación
HTTP básico.** Lo que sucede es que **si llama al método httpBasic()**, se agrega una instancia de
**BasicAuthenticationFilter a la cadena.** De manera similar, dependiendo de las configuraciones que escriba, la
definición de la cadena de filtros se ve afectada.

Agregas un nuevo filtro a la cadena relativo a otro (figura 9.4). O bien, puede agregar un filtro antes, después o en la
posición de uno conocido. Cada posición es, de hecho, un índice (un número), y es posible que también se le llame "the
order". Puede agregar dos o más filtros en la misma posición (figura 9.5). En la sección 9.4, encontraremos un caso
común en el que esto podría ocurrir, uno que suele crear confusión entre los desarrolladores.

![Add-custom-filter](./assets/Add-custom-filter.png)
![Same-order-number](./assets/Same-order-number.png)

## Agregar un filtro antes de uno existente en la cadena

Para nuestra primera implementación de filtro personalizado, consideremos un escenario trivial:

Queremos asegurarnos de que **cualquier solicitud tenga un encabezado llamado Request-Id.**
Asumimos que nuestra aplicación usa este encabezado para rastrear solicitudes y que este encabezado es
obligatorio. Al mismo tiempo, queremos validar estas suposiciones antes de que la aplicación realice la autenticación.
El proceso de autenticación puede implicar consultar la base de datos u otras acciones que consumen recursos y que no
queremos que la aplicación ejecute si el formato de la solicitud no es válido.
```¿Cómo hacemos esto?```

Resolver el requerimiento actual solo toma dos pasos, y al final, la cadena de filtros se parece a la de la figura 9.6:
![Custom-filter-implementation.png](./assets/Custom-filter-implementation.png)

**PASO 01**: Implementando el filtro personalizado: RequestValidationFilter

Dentro del método doFilter(), escribimos la lógica del filtro. En nuestro ejemplo, verificamos si existe el encabezado
Request-Id. Si es así, reenviamos la solicitud al siguiente filtro de la cadena llamando al método doFilter(). Si el
encabezado no existe, establecemos un estado HTTP 400 Solicitud incorrecta en la respuesta sin reenviarla al siguiente
filtro de la cadena:

````java
public class RequestValidationFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)
            throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;

        String requestId = httpRequest.getHeader("Request-Id");
        if (requestId == null || requestId.isBlank()) {
            httpResponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            return;
        }
        filterChain.doFilter(request, response); //<-- Reenvía la solicitud al siguiente filtro de la cadena
    }
}
````

**PASO 02**: Aplicando el filtro dentro de la clase de configuración

Usamos el método **addFilterBefore()** del objeto HttpSecurity porque queremos que la aplicación ejecute este filtro
personalizado antes de la autenticación. Este método recibe dos parámetros:

- **Una instancia del filtro personalizado que queremos agregar a la cadena**: en nuestro ejemplo esta es una instancia
  de nuestro filtro personalizado llamado RequestValidationFilter.
- **El tipo de filtro antes del cual agregamos la nueva instancia**: para este ejemplo, debido a que el requisito es
  ejecutar la lógica de filtro antes de la autenticación, debemos agregar nuestra instancia de filtro personalizado
  antes del filtro de autenticación. La clase BasicAuthenticationFilter define el tipo predeterminado del filtro de
  autenticación.

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.addFilterBefore(new RequestValidationFilter(), BasicAuthenticationFilter.class)
                .authorizeRequests().anyRequest().permitAll();
    }
}
````

Ahora puede ejecutar y probar la aplicación. Llamar al endpoint sin el encabezado genera una respuesta con el estado
HTTP 400 Bad Request. Si agrega el encabezado a la solicitud, el estado de la respuesta se convierte en HTTP 200 OK y
también verá el cuerpo de la respuesta, ¡Hello!

````bash
curl -v http://localhost:8080/greetings/hello

--- Respuesta ---
< HTTP/1.1 400
<
* Closing connection 0
````

````bash
curl -v -H "Request-Id:12345" http://localhost:8080/greetings/hello

--- Respuesta ---
< HTTP/1.1 200
<
¡Hello!
````

## Agregar un filtro después de uno existente en la cadena

Supongamos que tiene que ejecutar alguna lógica después del proceso de autenticación. Ejemplos de esto podrían ser
notificar a un sistema diferente después de ciertos eventos de autenticación o simplemente para fines de registro y
rastreo (figura 9.8).

Para nuestro ejemplo, registramos todos los eventos de autenticación exitosos agregando un filtro después del filtro de
autenticación (figura 9.8). Consideramos que lo que pasa por alto el filtro de autenticación representa un evento
autenticado con éxito y queremos registrarlo. Continuando con el ejemplo de la sección 9.1, también registramos el
Request-Id recibido a través del encabezado HTTP.

![Custom-filter-implementation-after.png](./assets/Custom-filter-implementation-after.png)

````java
public class AuthenticationLoginFilter implements Filter {
    private static final Logger LOG = LoggerFactory.getLogger(AuthenticationLoginFilter.class);

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)
            throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String requestId = httpRequest.getHeader("Request-Id");

        LOG.info("Successfully authenticated request with id: {}", requestId);

        filterChain.doFilter(request, response); //<-- Reenvía la solicitud al siguiente filtro de la cadena
    }
}
````

Para agregar el filtro personalizado en la cadena después del filtro de autenticación, llame al método addFilterAfter()
de HttpSecurity. La siguiente lista muestra la implementación.

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.addFilterBefore(new RequestValidationFilter(), BasicAuthenticationFilter.class)
                .addFilterAfter(new AuthenticationLoginFilter(), BasicAuthenticationFilter.class)
                .authorizeRequests().anyRequest().permitAll();
    }
}
````

Al ejecutar la aplicación y llamar al punto final, observamos que por cada llamada exitosa al punto final, la aplicación
imprime una línea de registro en la consola.

````bash
curl -v -H "Request-Id:12345" http://localhost:8080/greetings/hello

--- Respuesta ---
< HTTP/1.1 200
<
¡Hello!
````

````
2023-06-02 19:32:06.213  INFO 19792 --- [nio-8080-exec-1] c.m.b.s.a.f.AuthenticationLoginFilter    : Successfully authenticated request with id: 12345
````