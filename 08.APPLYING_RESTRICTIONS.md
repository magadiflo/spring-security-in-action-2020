# [Pág. 172] Capítulo 7 - Configuración de autorización: aplicación de restricciones

Spring Security le ofrece tres tipos de métodos de emparejamiento:

1. **MVC matchers**, utiliza expresiones MVC para rutas para seleccionar puntos finales.
2. **Ant matchers**, utilice expresiones Ant para rutas para seleccionar puntos finales.
3. **regex matchers**, utiliza expresiones regulares (regex) para rutas para seleccionar puntos finales.

## 1. Uso de métodos de comparación (matcher) para seleccionar puntos finales

Creamos una aplicación que expone dos puntos finales: /hello y /ciao. Queremos asegurarnos de que solo los usuarios que
tengan el rol ADMIN puedan llamar al punto final /hello. Del mismo modo, queremos asegurarnos de que solo los usuarios
que tengan el rol de MANAGER puedan llamar al punto final /ciao:

````java

@RestController
@RequestMapping(path = "/greetings")
public class HelloController {

    @GetMapping(path = "/hello")
    public String hello() {
        return "¡Hello!";
    }

    @GetMapping(path = "/ciao")
    public String ciao() {
        return "¡Ciao!";
    }
}
````

En la clase de configuración, declaramos un InMemoryUserDetailsManager como nuestra instancia de UserDetailsService y
agregamos tres usuarios con roles diferentes. El usuario admin tiene el rol de ADMIN, mientras que nophy tiene el
rol de MANAGER, el otro usuario tiene rol READER, pero ahora solo trabajaremos con los dos antes mencionados.

Para especificar que solo los usuarios que tienen el rol ADMIN pueden llamar al punto final /greetings/hello al
autorizar solicitudes, **usamos el método mvcMatchers().**

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.httpBasic();
        http.authorizeRequests()
                .mvcMatchers("/greetings/hello").hasRole("ADMIN")
                .mvcMatchers("/greetings/ciao").hasRole("MANAGER");
    }
}
````

Puede ejecutar y probar esta aplicación. Cuando llama al punto final /greetings/hello con el usuario admin, obtiene una
respuesta exitosa. Pero si llama al mismo punto final con el usuario martin o nophy, el estado de respuesta devuelve un
HTTP 403 Forbidden. De manera similar, para el punto final /greetings/ciao, solo puede usar nophy para obtener un
resultado exitoso. Para el usuario admin y martin, el estado de respuesta devuelve un HTTP 403 Forbidden.

Si ahora agrega cualquier otro punto final a su aplicación, **cualquiera puede acceder a él de forma predeterminada,
incluso los usuarios no autenticados.** Supongamos que agrega un nuevo punto final /hola como se presenta en la
siguiente lista:

````java

@RestController
@RequestMapping(path = "/greetings")
public class HelloController {

    @GetMapping(path = "/hello")
    public String hello() {
        return "¡Hello!";
    }

    @GetMapping(path = "/ciao")
    public String ciao() {
        return "¡Ciao!";
    }

    @GetMapping(path = "/hola")
    public String hola() {
        return "¡Hola!";
    }
}
````

Ahora, cuando acceda a este nuevo punto final, **verá que es accesible con o sin un usuario válido.**

````bash
curl -v http://localhost:8080/greetings/hola

--- Respuesta ---
< HTTP/1.1 200
< Date: Thu, 01 Jun 2023 23:56:00 GMT
<
¡Hola!
````

Si lo desea, puede hacer que este comportamiento sea más visible utilizando el método **permitAll()**. Para ello,
utilice el método de comparación anyRequest() al final de la cadena de configuración para la autorización de solicitud:

````
http.authorizeRequests()
                .mvcMatchers("/greetings/hello").hasRole("ADMIN")
                .mvcMatchers("/greetings/ciao").hasRole("MANAGER")
                .anyRequest().permitAll();
````

**NOTA**
> Cuando utilice comparadores para hacer referencia a solicitudes, el orden de las reglas debe ser:
> de lo más PARTICULAR a lo más GENERAL

Esta es la razón por la cual **el método anyRequest() no se puede llamar antes que un método de comparación más
específico como mvcMatchers().**

### No autenticado vs autenticación fallida

Si ha diseñado un punto final para que cualquiera pueda acceder a él, **puede llamarlo sin proporcionar un nombre de
usuario y una contraseña para la autenticación.** En este caso, **Spring Security no realizará la autenticación. Sin
embargo, si proporciona un nombre de usuario y una contraseña, Spring Security los evalúa en el proceso de
autenticación.** Si son incorrectos (desconocidos por el sistema), la autenticación falla y el estado de respuesta será
401 Unauthorized. Para ser más precisos, si llama al extremo /greetings/hola, la aplicación devuelve el cuerpo "¡Hola!",
como se esperaba, y el estado de respuesta es 200 OK. Por ejemplo:

````bash
 curl -v http://localhost:8080/greetings/hola

--- Respuesta --- 
< HTTP/1.1 200
<
¡Hola!
````

Pero si llama al punto final con credenciales no válidas, el estado de la respuesta es 401 Unauthorized.

````bash
curl -v -u admin:88888 http://localhost:8080/greetings/hola

--- Respuesta ---
< HTTP/1.1 401
````

Este comportamiento del framework puede parecer extraño, pero tiene sentido, ya que **el framework evalúa cualquier
nombre de usuario y contraseña si los proporciona en la solicitud.**

Ahora, puede decidir hacer que todos los demás puntos finales sean accesibles solo para usuarios autenticados. Para
hacer esto,
cambiaría el método permitAll() con .authenticated(); como se presenta en la siguiente lista.

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.httpBasic();
        http.authorizeRequests()
                .mvcMatchers("/greetings/hello").hasRole("ADMIN")
                .mvcMatchers("/greetings/ciao").hasRole("MANAGER")
                .anyRequest().authenticated();
    }
}
````

## 2. Selección de solicitudes de autorización mediante MVC matchers

En esta sección, analizamos los MVC matchers. **El uso de expresiones MVC es un enfoque común para hacer referencia
a las solicitudes para aplicar la configuración de autorización.**

**Este comparador usa la sintaxis estándar de MVC para hacer referencia a las rutas.** Esta sintaxis es la misma que usa
al escribir asignaciones de puntos finales con anotaciones como @RequestMapping, @GetMapping, @PostMapping, etc.

Los dos métodos que puede usar para declarar los MVC matchers son los siguientes:

- **mvcMatchers(HttpMethod method, String... patterns):** le permite especificar tanto el método HTTP al que se aplican
  las restricciones como las rutas. Este método es útil si desea aplicar diferentes restricciones para diferentes
  métodos HTTP para la misma ruta.
- **mvcMatchers(String... patterns):** más simple y fácil de usar si solo necesita aplicar restricciones de autorización
  basadas en rutas. Las restricciones pueden aplicarse automáticamente a cualquier método HTTP utilizado con la ruta.

En esta sección, abordamos múltiples formas de usar los métodos mvcMatchers(). Para demostrar esto, comenzamos
escribiendo una aplicación que expone múltiples puntos finales.

Por primera vez, escribimos puntos finales a los que se puede llamar con otros métodos HTTP además de GET. Es posible
que haya observado que, hasta ahora, he evitado usar otros métodos HTTP. La razón de esto es que **Spring Security
aplica, por defecto, protección contra la falsificación de solicitudes entre sitios (CSRF).** En el capítulo 1, describí
CSRF, que es una de las vulnerabilidades más comunes para las aplicaciones web.

Pero para simplificar las cosas en el ejemplo actual y poder llamar a todos los puntos finales, incluidos los expuestos
con POST, PUT o DELETE, debemos deshabilitar la protección CSRF en nuestro método configure():

````
http.csrf().disable();
````

**NOTA**
> Deshabilitamos la protección CSRF ahora solo para permitirle concentrarse por el momento en el tema discutido:
> métodos de emparejamiento. Pero no se apresure a considerar que este es un buen enfoque. En el capítulo 10,
> analizaremos en detalle la protección CSRF proporcionada por Spring Security.

Comenzamos definiendo cuatro puntos finales para usar en nuestras pruebas:

````java

@RestController
public class TestController {

    @PostMapping(path = "/a")
    public String postEndPointA() {
        return "Works!";
    }

    @GetMapping(path = "/a")
    public String getEndPointA() {
        return "Works!";
    }

    @GetMapping(path = "/a/b")
    public String getEndPointB() {
        return "Works!";
    }

    @GetMapping(path = "/a/b/c")
    public String getEndPointC() {
        return "Works!";
    }
}
````

### PRIMER ESCENARIO

Para las solicitudes realizadas con un método HTTP GET para la ruta /a, **la aplicación debe autenticar al usuario.**
Para la misma ruta, las solicitudes que utilizan un método HTTP POST no requieren autenticación. La aplicación niega
todas las demás solicitudes. La siguiente lista muestra las configuraciones que necesita escribir para lograr esta
configuración.

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.httpBasic();
        http.csrf().disable(); //<--- Deshabilita CSRF para habilitar una llamada a la ruta /a usando el método HTTP POST
        http.authorizeRequests()
                .mvcMatchers(HttpMethod.GET, "/a").authenticated()
                .mvcMatchers(HttpMethod.POST, "/a").permitAll()
                .anyRequest().denyAll();

    }
}
````

### SEGUNDO ESCENARIO

Queremos asegurarnos de que se apliquen las mismas reglas para todas las solicitudes de rutas que comiencen con /a/b.
Estos caminos en nuestro caso son /a/b y /a/b/c. Para lograr esto, <b>usamos el operador **</b>. (Spring MVC toma
prestadas las sintaxis de coincidencia de ruta de Ant).

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.httpBasic();
        http.csrf().disable();
        http.authorizeRequests()
                .mvcMatchers("/a/b/**").authenticated()
                .anyRequest().permitAll();

    }
}
````

> La expresión /a/b/** hace referencia a todas las rutas con el prefijo /a/b.

Con la configuración proporcionada en el código anterior, puede llamar a la ruta /a sin estar autenticado, pero para
todas las rutas con el prefijo /a/b, la aplicación necesita autenticar al usuario.

Como se presentó en los ejemplos anteriores, el operador ````**```` se refiere a cualquier número de rutas. Puede usarlo
como lo hicimos en el último ejemplo para que pueda hacer coincidir las solicitudes con rutas que tienen un prefijo
conocido. También puede usarlo en medio de una ruta para referirse a cualquier número de nombres de ruta o para
referirse a rutas que terminan en un patrón específico como ````/a/**/c````. Por lo tanto, ````/a/**/c```` no solo
coincidiría con /a/b/c sino también con /a/b/d/c y a/b/c/d/e/c y así sucesivamente. Si solo desea hacer coincidir un
nombre de ruta, puede usar un solo ````*````. Por ejemplo, ````a/*/c```` coincidiría con a/b/c y a/d/c pero no con
a/b/d/c.

### TERCER ESCENARIO

Tenemos un endpoint con una path variable y queremos denegar todas las solicitudes que usen un valor para el path
variable que tenga algo más que dígitos:

````java

@RestController
public class ProductController {

    @GetMapping(path = "/product/{code}")
    public String productCode(@PathVariable String code) {
        return code;
    }
}
````

A continuación se muestra cómo configurar la autorización de modo que solo se permitan siempre las llamadas que tienen
un valor que contiene solo dígitos, mientras que se niegan todas las demás llamadas:

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.httpBasic();
        http.csrf().disable();
        http.authorizeRequests()
                .mvcMatchers("/products/{code:^[0-9]*$}").permitAll()
                .anyRequest().denyAll();
    }
}
````
