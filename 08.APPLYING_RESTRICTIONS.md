# [Pág. 172] Capítulo 7 - Configuración de autorización: aplicación de restricciones

Spring Security le ofrece tres tipos de métodos de emparejamiento:

1. **MVC matchers**, utiliza expresiones MVC para rutas para seleccionar puntos finales.
2. **Ant matchers**, utilice expresiones Ant para rutas para seleccionar puntos finales.
3. **regex matchers**, utiliza expresiones regulares (regex) para rutas para seleccionar puntos finales.

## 1. Uso de métodos de comparación (matcher) para seleccionar puntos finales

Creamos una aplicación que expone dos puntos finales: /hello y /ciao. Queremos asegurarnos de que solo los usuarios que
tengan el rol ADMIN puedan llamar al punto final /hello. Del mismo modo, queremos asegurarnos de que solo los usuarios
que tengan el rol de MANAGER puedan llamar al punto final /ciao:

````java

@RestController
@RequestMapping(path = "/greetings")
public class HelloController {

    @GetMapping(path = "/hello")
    public String hello() {
        return "¡Hello!";
    }

    @GetMapping(path = "/ciao")
    public String ciao() {
        return "¡Ciao!";
    }
}
````

En la clase de configuración, declaramos un InMemoryUserDetailsManager como nuestra instancia de UserDetailsService y
agregamos tres usuarios con roles diferentes. El usuario admin tiene el rol de ADMIN, mientras que nophy tiene el
rol de MANAGER, el otro usuario tiene rol READER, pero ahora solo trabajaremos con los dos antes mencionados.

Para especificar que solo los usuarios que tienen el rol ADMIN pueden llamar al punto final /greetings/hello al
autorizar solicitudes, **usamos el método mvcMatchers().**

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.httpBasic();
        http.authorizeRequests()
                .mvcMatchers("/greetings/hello").hasRole("ADMIN")
                .mvcMatchers("/greetings/ciao").hasRole("MANAGER");
    }
}
````

Puede ejecutar y probar esta aplicación. Cuando llama al punto final /greetings/hello con el usuario admin, obtiene una
respuesta exitosa. Pero si llama al mismo punto final con el usuario martin o nophy, el estado de respuesta devuelve un
HTTP 403 Forbidden. De manera similar, para el punto final /greetings/ciao, solo puede usar nophy para obtener un
resultado exitoso. Para el usuario admin y martin, el estado de respuesta devuelve un HTTP 403 Forbidden.

Si ahora agrega cualquier otro punto final a su aplicación, **cualquiera puede acceder a él de forma predeterminada,
incluso los usuarios no autenticados.** Supongamos que agrega un nuevo punto final /hola como se presenta en la
siguiente lista:

````java

@RestController
@RequestMapping(path = "/greetings")
public class HelloController {

    @GetMapping(path = "/hello")
    public String hello() {
        return "¡Hello!";
    }

    @GetMapping(path = "/ciao")
    public String ciao() {
        return "¡Ciao!";
    }

    @GetMapping(path = "/hola")
    public String hola() {
        return "¡Hola!";
    }
}
````

Ahora, cuando acceda a este nuevo punto final, **verá que es accesible con o sin un usuario válido.**

````bash
curl -v http://localhost:8080/greetings/hola

--- Respuesta ---
< HTTP/1.1 200
< Date: Thu, 01 Jun 2023 23:56:00 GMT
<
¡Hola!
````

Si lo desea, puede hacer que este comportamiento sea más visible utilizando el método **permitAll()**. Para ello,
utilice el método de comparación anyRequest() al final de la cadena de configuración para la autorización de solicitud:

````
http.authorizeRequests()
                .mvcMatchers("/greetings/hello").hasRole("ADMIN")
                .mvcMatchers("/greetings/ciao").hasRole("MANAGER")
                .anyRequest().permitAll();
````

**NOTA**
> Cuando utilice comparadores para hacer referencia a solicitudes, el orden de las reglas debe ser:
> de lo más PARTICULAR a lo más GENERAL

Esta es la razón por la cual **el método anyRequest() no se puede llamar antes que un método de comparación más
específico como mvcMatchers().**

### No autenticado vs autenticación fallida

Si ha diseñado un punto final para que cualquiera pueda acceder a él, **puede llamarlo sin proporcionar un nombre de
usuario y una contraseña para la autenticación.** En este caso, **Spring Security no realizará la autenticación. Sin
embargo, si proporciona un nombre de usuario y una contraseña, Spring Security los evalúa en el proceso de
autenticación.** Si son incorrectos (desconocidos por el sistema), la autenticación falla y el estado de respuesta será
401 Unauthorized. Para ser más precisos, si llama al extremo /greetings/hola, la aplicación devuelve el cuerpo "¡Hola!",
como se esperaba, y el estado de respuesta es 200 OK. Por ejemplo:

````bash
 curl -v http://localhost:8080/greetings/hola

--- Respuesta --- 
< HTTP/1.1 200
<
¡Hola!
````

Pero si llama al punto final con credenciales no válidas, el estado de la respuesta es 401 Unauthorized.

````bash
curl -v -u admin:88888 http://localhost:8080/greetings/hola

--- Respuesta ---
< HTTP/1.1 401
````

Este comportamiento del framework puede parecer extraño, pero tiene sentido, ya que **el framework evalúa cualquier
nombre de usuario y contraseña si los proporciona en la solicitud.**

Ahora, puede decidir hacer que todos los demás puntos finales sean accesibles solo para usuarios autenticados. Para
hacer esto,
cambiaría el método permitAll() con .authenticated(); como se presenta en la siguiente lista.

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.httpBasic();
        http.authorizeRequests()
                .mvcMatchers("/greetings/hello").hasRole("ADMIN")
                .mvcMatchers("/greetings/ciao").hasRole("MANAGER")
                .anyRequest().authenticated();
    }
}
````