# [Pág. 387] Capítulo 16 - Seguridad global del método: Autorizaciones pre y post

Hasta ahora, discutimos varias formas de configurar la autenticación. Comenzamos con el enfoque más sencillo, HTTP basic
, en el capítulo 2, y luego le mostré cómo configurar el formulario de inicio de sesión en el capítulo 5. Cubrimos
OAuth 2 en los capítulos 12 al 15. Pero en términos de autorización, solo discutimos la configuración en el nivel del
endpoint.

Suponga que su aplicación no es una aplicación web, **¿no puede usar Spring Security también para autenticación y
autorización?** Spring Security es una buena opción para escenarios en los que su aplicación no se usa a través de
endpoints HTTP.

**En este capítulo, aprenderá a configurar la autorización a nivel de método.** Usaremos este **enfoque para**
configurar la autorización en **aplicaciones web y no web**, y lo llamaremos **seguridad de método global** (figura
16.1).

![figure-16-1](./assets/figure-16-1.png)

## [Pág. 388] Habilitación de la seguridad del método global

En esta sección, aprenderá cómo habilitar la autorización a nivel de método y las diferentes opciones que ofrece Spring
Security para aplicar varias reglas de autorización. **Este enfoque le proporciona una mayor flexibilidad a la hora de
solicitar la autorización.** Es una habilidad esencial que le permite resolver situaciones en las que la autorización
simplemente no se puede configurar solo a nivel de endpoint.

**De forma predeterminada, la seguridad del método global está deshabilitada**, por lo que si desea utilizar esta
funcionalidad, primero debe habilitarla. Además, la seguridad del método global ofrece múltiples enfoques para aplicar
la autorización. En resumen, puede hacer dos cosas principales con la seguridad de método global:

- **Call authorization**, decide si alguien **puede llamar a un método** de acuerdo con algunas reglas de privilegio
  implementadas **(autorización previa)** o si alguien puede acceder a lo que devuelve el método después de que se
  ejecuta **(autorización posterior).**
- **Filtering**, decide lo que un método puede recibir a través de sus parámetros (prefiltrado) y lo que la persona que
  llama puede recibir del método después de que se ejecuta el método (postfiltrado).

## [Pág. 389] Entendiendo la autorización de llamadas (Call authorization)

Uno de los enfoques para configurar las reglas de autorización que utiliza con la seguridad de método global es la
autorización de llamadas (call authorization). **El enfoque de autorización de llamadas se refiere a la aplicación de
reglas de autorización que deciden si se puede llamar a un método, o que permiten que se llame al método y luego deciden
si la persona que llama puede acceder al valor devuelto por el método.** A menudo, necesitamos decidir si alguien puede
acceder a una parte de la lógica según los parámetros proporcionados o su resultado.

¿Cómo funciona la seguridad del método global? ¿Cuál es el mecanismo detrás de la aplicación de las reglas de
autorización? Cuando habilitamos la seguridad del método global en nuestra aplicación, en realidad habilitamos un
aspecto de Spring. Este **aspecto intercepta las llamadas al método para el que aplicamos reglas de autorización y, en
base a estas reglas de autorización, decide si reenvía la llamada al método interceptado** (figura 16.2).

![figure-16-2](./assets/figure-16-2.png)

Muchas implementaciones en Spring Framework se basan en la programación orientada a aspectos (AOP). La seguridad del
método global es solo uno de los muchos componentes de las aplicaciones Spring que se basan en aspectos. Brevemente,
clasificamos la autorización de llamada como:

- **PreAuthorization**: el marco comprueba las reglas de autorización antes de la llamada al método.
- **PostAuthorization**: el marco verifica las reglas de autorización después de que se ejecuta el método.

### [Pág. 390] Uso del PreAuthorization para garantizar el acceso a los métodos

Digamos que tenemos un método findDocumentsByUser(String username) que regresa los documentos a la persona que llama
para un usuario específico. La persona que llama proporciona a través de los parámetros del método el nombre del usuario
para el cual el método recupera los documentos. Suponga que necesita asegurarse de que el usuario autenticado solo pueda
obtener sus propios documentos. **¿Podemos aplicar una regla a este método de modo que solo se permitan las llamadas al
método que recibe como parámetro el nombre del usuario autenticado?** ¡Sí! Esto es algo que hacemos con la autorización
previa.

**Cuando aplicamos reglas de autorización que prohíben por completo que alguien llame a un método en situaciones
específicas, lo llamamos preautorización** (figura 16.3). Este enfoque implica que el marco verifica las condiciones de
autorización antes de ejecutar el método. Si la persona que llama no tiene los permisos de acuerdo con las reglas de
autorización que definimos, el marco no delega la llamada al método. En su lugar, el marco lanza una excepción. Este es,
con mucho, el enfoque más utilizado para la seguridad de métodos globales.

Por lo general, no queremos que se ejecute una funcionalidad si no se cumplen algunas condiciones. **Puede aplicar
condiciones basadas en el usuario autenticado y también puede hacer referencia a los valores que recibió el método a
través de sus parámetros.**

![figure-16-3](./assets/figure-16-3.png)

### [Pág. 391] Uso del PostAuthorization para asegurar una llamada de método

Cuando aplicamos reglas de autorización que permiten a alguien llamar a un método pero **no necesariamente obtener el
resultado devuelto por el método**, estamos usando la postAuthorization (figura 16.4).

Con postAuthorization, Spring Security verifica las reglas de autorización después de que se ejecuta el método. Puede
utilizar este tipo de autorización para restringir el acceso a la devolución del método en determinadas condiciones.
Debido a que el postAuthorization ocurre después de la ejecución del método, puede aplicar las reglas de
autorización en el resultado devuelto por el método.

![figure-16-4](./assets/figure-16-4.png)

Por lo general, usamos el postAuthorization para aplicar reglas de autorización basadas en lo que devuelve el método
después de la ejecución. **¡Pero tenga cuidado con el postAuthorization!** Si el método muta algo durante su ejecución,
el cambio ocurre ya sea que la autorización tenga éxito o no al final.

**NOTA**
> Incluso con la anotación @Transactional, un cambio no se revierte si falla el postAuthorization. La excepción lanzada
> por la funcionalidad del postAuthorization ocurre después de que el administrador de transacciones confirma la
> transacción (commit).

## [Pág. 391] Habilitación de la seguridad de métodos globales en su proyecto

En esta sección, trabajamos en un proyecto para aplicar las **características de preAuthorization y postAuthorization
que ofrece la seguridad de método global**. La seguridad del método global **no está habilitada de forma predeterminada
en un proyecto de Spring Security.** Sin embargo, **habilitar esta funcionalidad es sencillo**. Puede hacer esto
simplemente usando la anotación **@EnableGlobalMethodSecurity** en la clase de configuración.

La seguridad de método global nos ofrece tres enfoques para definir las reglas de autorización que analizamos en este
capítulo:

- ``Las anotaciones PreAuthorization y PostAuthorization.``
- La anotación JSR 250, @RolesAllowed
- La anotación @Secured

Debido a que **en casi todos los casos, las anotaciones preAuthorization y postAuthorization son el único enfoque
utilizado**, analizamos este enfoque en este capítulo. **Para habilitar este enfoque**, usamos el atributo
**prePostEnabled de la anotación @EnableGlobalMethodSecurity.** Presentamos una breve descripción de las otras dos
opciones mencionadas anteriormente al final de este capítulo.

````java

@EnableGlobalMethodSecurity(prePostEnabled = true)
@Configuration
public class ProjectConfig {
}
````

Puede utilizar la seguridad de método global (GlobalMethodSecurity) con cualquier método de autenticación, desde la
autenticación **HTTP Basic hasta OAuth 2.** Para mantenerlo simple y permitirle concentrarse en nuevos detalles,
proporcionamos seguridad de método global con autenticación HTTP Basic. Por esta razón, **el archivo pom.xml para los
proyectos de este capítulo solo necesita las dependencias web y Spring Security**, como se presenta en el siguiente
fragmento de código:

````xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.magadiflo.book.security</groupId>
    <artifactId>spring-security-in-action-2020</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>spring-security-in-action-2020</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
````
