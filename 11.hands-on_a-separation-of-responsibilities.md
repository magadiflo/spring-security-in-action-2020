# [Pág. 244] Capítulo 11 - Manos a la obra: una separación de responsabilidades

En este capítulo, diseñaremos un sistema de tres actores: **el cliente, el servidor de autenticación y el servidor de
lógica empresarial.** A partir de estos tres actores, implementaremos la parte de backend del servidor de autenticación
y un servidor de lógica empresarial.

## El escenario y los requisitos del ejemplo

La arquitectura del sistema que diseñaremos tiene tres componentes:

- **El cliente**: esta es la aplicación que consume el backend. Podría ser una aplicación móvil o la interfaz de una
  aplicación web desarrollada con un framework como Angular, ReactJS o Vue.js. No implementamos la parte del cliente del
  sistema, pero tenga en cuenta que existe en una aplicación del mundo real. En lugar de usar el cliente para llamar a
  los puntos finales, usamos cURL.
- **El servidor de autenticación**: esta es una aplicación con una base de datos de credenciales de usuario. El
  propósito de esta aplicación es autenticar a los usuarios en función de sus credenciales (nombre de usuario y
  contraseña) y enviarles una contraseña de un solo uso (OTP) a través de SMS. Debido a que en realidad no enviaremos un
  SMS en este ejemplo, leeremos el valor de la OTP directamente desde la base de datos. En este capítulo, implementamos
  toda esta aplicación sin enviar el SMS.
- **El servidor de lógica empresarial**: esta es la aplicación que expone los endpoints que consume nuestro cliente.
  Queremos asegurar el acceso a estos endpoints. Antes de llamar a un endpoint el usuario debe autenticarse con su
  nombre de usuario y contraseña y luego enviar una OTP. El usuario recibe la OTP a través de un mensaje SMS. Debido a
  que esta aplicación es nuestra aplicación de destino, la protegeremos con Spring Security.

![hands-on_a-separation-of-responsibilities-escenario-1](./assets/hands-on_a-separation-of-responsibilities-escenario-1.png)

Para llamar a cualquier punto final en el servidor de lógica de negocios, el cliente debe seguir tres pasos:

1. Autenticar el nombre de usuario y la contraseña llamando al punto final /login en el servidor de lógica de negocios
   para obtener una OTP generada aleatoriamente.
2. Llame al punto final /login con el nombre de usuario y OTP.
3. Llame a cualquier endpoint agregando el token recibido en el paso 2 al encabezado de Autorización de la solicitud
   HTTP.

Cuando el cliente autentica el nombre de usuario y la contraseña, el servidor de lógica de negocio envía una solicitud
de OTP al servidor de autenticación. Después de una autenticación exitosa, el servidor de autenticación envía una OTP
generada aleatoriamente al cliente a través de SMS. **Esta forma de identificar al usuario se llama
autenticación multifactor (MFA)**, y es bastante común hoy en día. Por lo general, necesitamos que los usuarios
demuestren quiénes son usando sus credenciales y con otro medio de identificación (por ejemplo, que poseen un
dispositivo móvil específico).

![first-step-authentication](./assets/first-step-authentication.png)

En el segundo paso de autenticación, una vez que el cliente tiene el código del SMS recibido, el usuario puede llamar al
punto final /login, nuevamente con el nombre de usuario y el código. El servidor de lógica empresarial valida el código
con el servidor de autenticación. Si el código es válido, el cliente recibe un token que puede usar para llamar a
cualquier punto final en el servidor de lógica de negocio.

![Second-authentication-step](./assets/Second-authentication-step.png)

En el tercer paso de autenticación, el cliente ahora puede llamar a cualquier endpoint agregando el token que recibió en
el paso 2 al encabezado de Autorización de la solicitud HTTP.

![third-authentication-step](./assets/third-authentication-step.png)

**NOTA**

> Este ejemplo nos permite trabajar en una aplicación más grande, que incluye más de los conceptos que discutimos en
> capítulos anteriores. Para permitirle concentrarse en los conceptos de Spring Security que quiero incluir en la
> aplicación, simplifico la arquitectura del sistema. Alguien podría argumentar que esta arquitectura utiliza enfoques
> viciosos ya que el cliente solo debe compartir contraseñas con el servidor de autenticación y nunca con el servidor de
> lógica empresarial. ¡Esto es correcto! En nuestro caso, es solo una simplificación. En escenarios del mundo real, en
> general, nos esforzamos por mantener las credenciales y los secretos conocidos por la menor cantidad posible de
> componentes en el sistema. Además, alguien podría argumentar que el escenario MFA en sí mismo podría implementarse más
> fácilmente mediante el uso de un sistema de administración de terceros como Okta o algo similar. Parte del propósito
> del ejemplo es enseñarle cómo definir filtros personalizados. Por esta razón, elegí la forma difícil de implementar,
> nosotros mismos, esta parte de la arquitectura de autenticación.

## [Pág. 248] Implementación y uso de tokens

Una aplicación obtiene un token como resultado del proceso de autenticación y para acceder a los recursos. Los puntos
finales representan los recursos en una aplicación web. Para una aplicación web, un token es una cadena, generalmente
enviada a través de un encabezado HTTP por clientes que desean acceder a un punto final en particular. Esta cadena puede
ser simple como un identificador único universal (UUID) puro, o puede tener una forma más compleja como un token web
JSON (JWT).

**¿Qué es un token?**, los tokens proporcionan un método que utiliza una aplicación para demostrar que ha autenticado a
un usuario, lo que le permite acceder a los recursos de la aplicación.

**¿Qué es un JWT?**

* **JSON**, utiliza JSON para formatear los datos que contiene.
* **Web**, está diseñado para ser utilizado para solicitudes web.
* **Token**, es una implementación de token.

JWT es una implementación de token. Agrega el beneficio de transferir datos fácilmente durante la autenticación, así
como firmar datos para validar su integridad.

![JWT-parts.png](./assets/JWT-parts.png)

En este capítulo, usaremos [Java JSON Web Token (JJWT)](https://github.com/jwtk/jjwt#overview) como biblioteca para
crear y analizar JWT. Esta es una de las bibliotecas más utilizadas para generar y analizar tokens JWT en aplicaciones
Java.

## [Pág. 253] Implementando el servidor de autenticación

El código fuente está en el siguiente
repositorio: [spring-security-in-action-2020-cap-11-authentication-server](https://github.com/magadiflo/spring-security-in-action-2020-cap-11-authentication-server.git)

En esta sección, comenzamos la implementación de nuestro ejemplo práctico. **La primera dependencia que tenemos es el
servidor de autenticación.** Incluso si no es la aplicación en la que nos enfocamos al usar Spring Security, la
necesitamos para nuestro resultado final.

En nuestro escenario, el servidor de autenticación se conecta a una base de datos donde almacena las credenciales de
usuario y las OTP generadas durante los eventos de autenticación de solicitudes. Necesitamos esta aplicación para
exponer tres endpoints.

- **/user/add**, agrega un usuario que usaremos más tarde para probar nuestra implementación.
- **/user/auth**, autentica a un usuario por sus credenciales y envía un SMS con una OTP. Quitamos la parte que envía el
  SMS, pero esto lo puedes hacer como ejercicio.
- **/otp/check**, verifica que un valor OTP sea el que el servidor de autenticación generó anteriormente para un usuario
  específico.

![class-design-for-an-authentication-server](./assets/class-design-for-an-authentication-server.png)

Las dependencias a usar para esta versión de Spring Boot 2.6.4:

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el archivo application.properties, proporcionamos los parámetros que necesita Spring Boot para crear el Data source.
El siguiente fragmento de código muestra el contenido del archivo application.properties:

````properties
# Datasource MySQL
spring.datasource.url=jdbc:mysql://localhost:3306/db_spring_security_in_action_2020?serverTimezone=America/Lima
spring.datasource.username=root
spring.datasource.password=magadiflo
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# Configurando dialecto a MySQL
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
# Generar tablas: create, crea el esquema y destruye los datos previos
spring.jpa.hibernate.ddl-auto=create
# Vista y formato en el log
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
````

La clase de configuración para el servidor de autenticación:

- Deshabilite CSRF para que podamos llamar a todos los puntos
  finales de la aplicación directamente.
- Permite todas las llamadas sin autenticación.

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();
        http.authorizeRequests().anyRequest().permitAll();
    }
}
````

Definimos un codificador de contraseñas para codificar las contraseñas almacenadas en la base de datos:

````java

@Configuration
public class UserManagementConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

}
````

Las entidades que participan en la autenticación:

````java

@Entity
@Table(name = "users")
public class User {
    @Id
    private String username;
    private String password;

    /* setters, getters and toString() */
}
````

````java

@Entity
@Table(name = "otps")
public class Otp {
    @Id
    private String username;
    private String code;

    /* setters, getters and toString() */
}
````

Los repositorios asociados a cada entity:

````java
public interface UserRepository extends JpaRepository<User, String> {
    Optional<User> findUserByUsername(String username);
}
````

````java
public interface OtpRepository extends JpaRepository<Otp, String> {
    Optional<Otp> findOtpByUsername(String username);
}
````

Con los repositorios y las entidades en su lugar, podemos trabajar en la lógica de la aplicación. Para esto, creo una
clase de servicio que llamo UserService. Como se muestra en el siguiente código, el servicio tiene dependencias en los
repositorios y el codificador de contraseñas. Debido a que usamos estos objetos para implementar la lógica de la
aplicación, necesitamos autoconectarlos.

````java

@Service
@Transactional
public class UserService {
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private OtpRepository otpRepository;

    public void addUser(User user) {
        user.setPassword(this.passwordEncoder.encode(user.getPassword()));
        this.userRepository.save(user);
    }

    public void auth(User user) {
        Optional<User> optionalUserDB = this.userRepository.findUserByUsername(user.getUsername());
        if (optionalUserDB.isPresent()) {
            User userDB = optionalUserDB.get();
            if (this.passwordEncoder.matches(user.getPassword(), userDB.getPassword())) {
                this.renewOtp(userDB);
            } else {
                throw new BadCredentialsException("Credenciales incorrectos! El password no hace match!");
            }
        } else {
            throw new BadCredentialsException("Credenciales incorrectos! El username " + user.getUsername() + " no existe!");
        }
    }

    public boolean check(Otp otpToValidate) {
        Optional<Otp> otpByUsername = this.otpRepository.findOtpByUsername(otpToValidate.getUsername());
        if (otpByUsername.isPresent()) {
            Otp otpDB = otpByUsername.get();
            return otpToValidate.getCode().equals(otpDB.getCode());
        }
        return false;
    }

    private void renewOtp(User user) {
        String code = GenerateCodeUtil.generateCode();
        Optional<Otp> optionalUserOtpDB = this.otpRepository.findOtpByUsername(user.getUsername());

        if (optionalUserOtpDB.isPresent()) {
            Otp otpDB = optionalUserOtpDB.get();
            otpDB.setCode(code);
        } else {
            Otp otp = new Otp();
            otp.setUsername(user.getUsername());
            otp.setCode(code);
            this.otpRepository.save(otp);
        }
    }
}
````

El siguiente código presenta la clase GenerateCodeUtil. Usamos esta clase para generar el nuevo valor OTP.

````java
public class GenerateCodeUtil {
    private GenerateCodeUtil() {
    }

    public static String generateCode() {
        String code;
        try {
            SecureRandom random = SecureRandom.getInstanceStrong();
            code = String.valueOf(random.nextInt(9000) + 1000);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Problemas al generar el código aleatorio!!!");
        }
        return code;
    }
}
````

Finalmente, en esta aplicación exponemos la lógica presentada con un controlador. La siguiente lista define este
controlador:

````java

@RestController
public class AuthController {
    @Autowired
    private UserService userService;

    @PostMapping(path = "/user/add")
    public void addUser(@RequestBody User user) {
        this.userService.addUser(user);
    }

    @PostMapping(path = "/user/auth")
    public void auth(@RequestBody User user) {
        this.userService.auth(user);
    }

    @PostMapping(path = "/otp/check")
    public void check(@RequestBody Otp otp, HttpServletResponse response) {
        if (this.userService.check(otp)) {
            response.setStatus(HttpServletResponse.SC_OK);
        } else {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        }
    }
}

````

Con esta configuración, ahora tenemos el servidor de autenticación. Comencemos y asegurémonos de que los puntos finales
funcionen de la manera que esperamos. Para probar la funcionalidad del servidor de autenticación, necesitamos:

1. Agregue un nuevo usuario a la base de datos llamando al punto final /user/add.
2. Valide que el usuario se agregó correctamente al verificar la tabla de usuarios en la base de datos.
3. Llame al punto final /user/auth para el usuario agregado en el paso 1.
4. Validar que la aplicación genere y almacene una OTP en la tabla otp.
5. Use la OTP generada en el paso 3 para validar que el punto final /otp/check funciona como se desea.

- Agregando un nuevo usuario

````bash
curl -v -X POST -H "content-type: application/json" -d "{\"username\":\"admin\", \"password\": \"12345\"}" http://localhost:8080/user/add

-- Respuesta ---
< HTTP/1.1 200
<
* Connection #0 to host localhost left intact
````

- Generemos una OTP para el usuario llamado al endpoint /user/auth

````bash
curl -v -X POST -H "content-type: application/json" -d "{\"username\":\"admin\", \"password\": \"12345\"}" http://localhost:8080/user/auth

--- Respuesta ---
< HTTP/1.1 200
<
* Connection #0 to host localhost left intact
````

- El último paso para probar nuestro servidor de autenticación es llamar al extremo /otp/check y verificar que devuelve
  un código de estado HTTP 200 OK en la respuesta cuando la OTP es correcta y 403 Forbidden si el OTP está mal.

````bash
--- Código OTP existente ---
curl -v -X POST -H "content-type: application/json" -d "{\"username\":\"admin\", \"code\": \"7699\"}" http://localhost:8080/otp/check

--- Respuesta ---
< HTTP/1.1 200
<
* Connection #0 to host localhost left intact
````

````bash
--- Código OTP no existente ---
curl -v -X POST -H "content-type: application/json" -d "{\"username\":\"admin\", \"code\": \"8877\"}" http://localhost:8080/otp/check

--- Respuesta ---
< HTTP/1.1 403
<
* Connection #0 to host localhost left intact
````

**¡Acabamos de demostrar que los componentes del servidor de autenticación funcionan!**

Ahora podemos sumergirnos en el siguiente elemento para el que escribimos la mayoría de las configuraciones de Spring
Security para nuestro ejemplo práctico actual: **el servidor de lógica de negocio.**

---

## [Pág. 263] Implementando el servidor de lógica de negocio

El código fuente estará en el siguiente repositorio: [spring-security-in-action-2020-cap-11-business-logic-server]

En esta sección, implementamos el servidor de lógica de negocios. Con esta aplicación, reconocerá muchas de las cosas
que discutimos hasta este punto en el libro. Con esta parte del sistema, **aprenderá a implementar y
utilizar JWT para autenticación y autorización.** Además, implementamos la comunicación entre el servidor de lógica
de negocio y el servidor de autenticación para establecer la autenticación de múltiples factores (MFA) en su aplicación.

Para llevar a cabo nuestra tarea, a un alto nivel, necesitamos:

1. Cree un endpoint que represente el recurso que queremos proteger.
2. Implemente el primer paso de autenticación en el que el cliente envía las credenciales de usuario (nombre de usuario
   y contraseña) al servidor de lógica de negocio para iniciar sesión.
3. Implemente el segundo paso de autenticación en el que el cliente envía la OTP que el usuario recibe del servidor de
   autenticación al servidor de lógica de negocio. Una vez autenticado por la OTP, el cliente obtiene un JWT, que puede
   usar para acceder a los recursos de un usuario.
4. Implementar la autorización basada en el JWT. El servidor de lógica de negocio valida el JWT recibido de un cliente
   y, si es válido, permite que el cliente acceda al recurso.

Empezamos con las dependencias. La siguiente lista muestra las dependencias que necesita agregar al archivo pom.xml.
Recordar que estamos usando Spring Boot 2.6.4 y Java 17:

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- Dependencias de jjwt para generar y analizar JWT -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.11.1</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.11.1</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.11.1</version>
        <scope>runtime</scope>
    </dependency>
    <!-- Necesitamos esto si usamos Java 10 o superior -->
    <dependency>
        <groupId>jakarta.xml.bind</groupId>
        <artifactId>jakarta.xml.bind-api</artifactId>
    </dependency>
    <dependency>
        <groupId>org.glassfish.jaxb</groupId>
        <artifactId>jaxb-runtime</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En esta aplicación, solo definimos un punto final /test. Todo lo demás que escribimos en este proyecto es para asegurar
este punto final. El punto final /test está expuesto por la clase TestController, que se presenta en la siguiente lista.

````java

@RestController
public class TestController {
    @GetMapping(path = "/test")
    public String test() {
        return "Test!";
    }
}
````

Para asegurar la aplicación ahora, tenemos que definir los tres niveles de autenticación:

1. Autenticación con usuario y contraseña para recibir una OTP:

![first-authentication-step](./assets/first-authentication-step.png)

2. Autenticación con OTP para recibir un token:

![second-authentication-step-otp](./assets/second-authentication-step-otp.png)

3. Autenticación con el token para acceder al endpoint:

![last-authentication-step](./assets/last-authentication-step.png)

Con los requisitos dados para este ejemplo, que es más complejo y supone varios pasos de autenticación, la autenticación
HTTP basic ya no puede ayudarnos. Necesitamos implementar filtros especiales y proveedores de autenticación para
personalizar la lógica de autenticación para nuestro escenario. Afortunadamente, aprendió a definir filtros
personalizados en el capítulo 9, así que revisemos la arquitectura de autenticación en Spring Security:

![authentication-architecture-spring-security](./assets/authentication-architecture-spring-security.png)

A menudo, al desarrollar una aplicación, hay más de una buena solución. Al diseñar una arquitectura, siempre debe pensar
en todas las implementaciones posibles y elegir la que mejor se adapte a su escenario. Si se aplica más de una opción y
no puede decidir cuál es la mejor para implementar, debe escribir una prueba de concepto para cada opción para ayudarlo
a decidir qué solución elegir. **Para nuestro escenario**, presento **dos opciones**, y luego **continuamos la
implementación con una de estas.** Dejo la otra opción como un ejercicio para que usted lo implemente.

La primera opción para nosotros es definir tres objetos de autenticación personalizados, **tres objetos
AuthenticationProvider personalizados** y **un filtro personalizado** para **delegar** a estos **mediante el uso de
AuthenticationManager**. Aprendió a implementar las interfaces Authentication y AuthenticationProvider en
el capítulo 5.

![first-option](./assets/first-option.png)

La segunda opción, que elegí implementar en este ejemplo, es tener dos objetos Authentication personalizados y dos
objetos AuthenticationProvider personalizados. Estos objetos pueden ayudarnos a aplicar la lógica relacionada con el
punto final /login:

- Autenticar al usuario con usuario y contraseña
- Autenticar al usuario con un OTP

Luego implementamos la validación del token con un segundo filtro. La figura 11.16 presenta este enfoque:

![second-option](./assets/second-option.png)

Ambos enfoques son igualmente buenos. Describo ambos solo para ilustrar que puede encontrar casos en los que tiene
varias formas de desarrollar el mismo escenario, especialmente porque Spring Security ofrece una arquitectura bastante
flexible.

**El autor del libro eligió el segundo** porque ofrece la posibilidad de resumir más cosas, como tener múltiples filtros
personalizados y usar el método shouldNotFilter() de la clase OncePerRequestFilter. Discutimos brevemente esta clase en
la sección 9.5, pero no tuve la oportunidad de aplicar el método shouldNotFilter() con un ejemplo. Aprovechamos esta
oportunidad ahora.

## Implementación de los objetos de autenticación

En esta sección, implementamos los dos objetos de autenticación que necesitamos para que nuestra solución desarrolle el
servidor de lógica empresarial. Al comienzo de la sección 11.4, creamos el proyecto y agregamos las dependencias
necesarias. También creamos un punto final que queremos proteger y decidimos cómo implementar el diseño de clase para
nuestro ejemplo. **Necesitamos dos tipos de objetos de autenticación**, uno para representar la **autenticación por
nombre de usuario y contraseña** y un segundo para representar la **autenticación por OTP**. Como aprendió en el
capítulo 5, **el contrato de autenticación representa el proceso de autenticación de una solicitud.**
Puede ser un proceso en curso o después de su finalización. Necesitamos implementar la interfaz de Autenticación tanto
para los casos en los que la aplicación autentica al usuario con su nombre de usuario y contraseña, como para una OTP.

En el listado 11.14, encontrará la clase UsernamePasswordAuthentication, que implementa la autenticación con nombre de
usuario y contraseña. Para acortar las clases, extiendo la clase UsernamePasswordAuthenticationToken e, indirectamente,
la interfaz de autenticación. Viste la clase UsernamePasswordAuthenticationToken en el capítulo 5, donde analizamos la
aplicación de una lógica de autenticación personalizada.

````java
public class UsernamePasswordAuthentication extends UsernamePasswordAuthenticationToken {
    public UsernamePasswordAuthentication(Object principal, Object credentials) {
        super(principal, credentials);
    }

    public UsernamePasswordAuthentication(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities) {
        super(principal, credentials, authorities);
    }
}
````

Tenga en cuenta que defino ambos constructores en esta clase. Hay una gran diferencia entre estos:

- **cuando llama al que tiene dos parámetros**, la instancia de autenticación permanece sin autenticar.
- **mientras el que tiene tres parámetros establece el objeto de autenticación como autenticado.**

Como aprendió en el capítulo 5, **cuando se autentica la instancia de Autenticación, significa que el proceso de
autenticación finaliza.** Si el objeto de autenticación no está configurado como autenticado y no se genera ninguna
excepción durante el proceso, AuthenticationManager intenta encontrar un objeto AuthenticationProvider adecuado para
autenticar la solicitud.

Usamos el constructor con dos parámetros cuando construimos inicialmente el objeto de autenticación y aún no está
autenticado. Cuando un objeto AuthenticationProvider autentica la solicitud, crea una instancia de autenticación
utilizando el constructor con tres parámetros, lo que crea un objeto autenticado. El tercer parámetro es la colección de
autorizaciones otorgadas, que es obligatoria para un proceso de autenticación que ha finalizado.

De manera similar a UsernamePasswordAuthentication, implementamos el segundo objeto de autenticación para el segundo
paso de autenticación con OTP. Llamo a esta clase OtpAuthentication. El listado 11.15 demuestra que la clase extiende el
UsernamePasswordAuthenticationToken. Podemos usar la misma clase porque tratamos la OTP como una contraseña. Debido a
que es similar, usamos el mismo enfoque para guardar algunas líneas de código.

````java
public class OtpAuthentication extends UsernamePasswordAuthenticationToken {
    public OtpAuthentication(Object principal, Object credentials) {
        super(principal, credentials);
    }

    public OtpAuthentication(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities) {
        super(principal, credentials, authorities);
    }
}

````

## Implementación del proxy al servidor de autenticación

En esta sección, construimos una forma de llamar al endpoint REST expuesto por el servidor de autenticación.
Inmediatamente después de definir los objetos de autenticación, generalmente implementamos los objetos
AuthenticationProvider (figura 11.17). Sabemos, sin embargo, que para completar la autenticación, necesitamos una forma
de llamar al servidor de autenticación. Continúo ahora con la implementación de un proxy para el servidor de
autenticación antes de implementar los objetos AuthenticationProvider.

![authentication-server-proxy](./assets/authentication-server-proxy.png)

Para esta implementación, necesitamos:

- Defina una clase de modelo User que usaremos para llamar a los servicios REST expuestos en el servidor de
  autenticación.
- Declare un bean de tipo RestTemplate, que usamos para llamar a los endpoints REST expuestos por el servidor de
  autenticación.
- Implemente la clase proxy, que define dos métodos: uno para autenticación de nombre de usuario/contraseña y la otra
  para autenticación de nombre de usuario/otp.

La siguiente lista presenta la clase de modelo User:

````java
public class User {
    private String username;
    private String password;
    private String code;

    /* setters, getters and toString() */
}
````

La siguiente lista presenta la clase de configuración del cliente rest. Llamo a esta clase RestTemplateConfig y defino
un bean RestTemplate para la clase de proxy que desarrollamos a continuación.

````java

@Configuration
public class RestTemplateConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
````

Ahora podemos escribir la clase **AuthenticationServerProxy**, que usamos para **llamar a los dos
endpoints** REST **expuestos** por la aplicación del **servidor de autenticación.**
El siguiente listado presenta esta clase.

````java

@Component
public class AuthenticationServerProxy {
    @Autowired
    private RestTemplate restTemplate;
    @Value("${auth.server.base.url}")
    private String baseUrl;

    public void sendAuth(String username, String password) {
        String url = this.baseUrl + "/user/auth";

        User user = new User();
        user.setUsername(username);
        user.setPassword(password);

        HttpEntity<User> request = new HttpEntity<>(user);

        this.restTemplate.postForEntity(url, request, Void.class);
    }

    public boolean sendOTP(String username, String code) {
        String url = this.baseUrl + "/otp/check";

        User user = new User();
        user.setUsername(username);
        user.setCode(code);

        HttpEntity<User> request = new HttpEntity<>(user);

        ResponseEntity<Void> response = this.restTemplate.postForEntity(url, request, Void.class);
        return response.getStatusCode().equals(HttpStatus.OK);
    }
}
````

A continuación se muestra la configuración agregada en el application.properties:

````properties
server.port=9090
auth.server.base.url=http://localhost:8080
jwt.signing.key=ymLTU8rq83j4fmJZj60wh4OrMNuntIj4fmJ
````

## [Pág. 272] Implementación de la interfaz AuthenticationProvider

En esta sección, implementamos las clases AuthenticationProvider. Ahora tenemos todo lo que necesitamos para comenzar a
trabajar en los proveedores de autenticación. Los necesitamos porque aquí es donde escribimos la lógica de autenticación
personalizada.

Creamos una clase llamada **UsernamePasswordAuthenticationProvider** para servir el tipo de Autenticación
UsernamePasswordAuthentication, como se describe en el listado 11.19. Debido a que **diseñamos nuestro flujo para que
tenga dos pasos de autenticación** y tenemos un filtro que se encarga de ambos pasos, sabemos que **la autenticación no
termina con este proveedor.** Usamos el constructor con dos parámetros para construir el objeto de autenticación: new
UsernamePasswordAuthenticationToken(username, password). **Recuerde**, discutimos en la sección 11.4.1 que **el
constructor con dos parámetros no marca el objeto como autenticado.**

````java

@Component
public class UsernamePasswordAuthenticationProvider implements AuthenticationProvider {
    @Autowired
    private AuthenticationServerProxy proxy;

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        String username = authentication.getName();
        String password = String.valueOf(authentication.getCredentials());
        this.proxy.sendAuth(username, password);

        return new UsernamePasswordAuthenticationToken(username, password);
    }

    @Override
    public boolean supports(Class<?> authentication) {
        return UsernamePasswordAuthentication.class.isAssignableFrom(authentication);
    }
}
````

El listado 11.20 presenta el proveedor de autenticación diseñado para el tipo de autenticación OtpAuthentication. La
lógica implementada por este AuthenticationProvider es simple. Llama al servidor de autenticación para averiguar si la
OTP es válida. Si la OTP es correcta y válida, devuelve una instancia de Autenticación. El filtro devuelve el token en
la respuesta HTTP. Si la OTP no es correcta, el proveedor de autenticación genera una excepción.

````java

@Component
public class OtpAuthenticationProvider implements AuthenticationProvider {
    @Autowired
    private AuthenticationServerProxy proxy;

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        String username = authentication.getName();
        String code = String.valueOf(authentication.getCredentials());
        boolean result = this.proxy.sendOTP(username, code);

        if (result) {
            return new OtpAuthentication(username, code);
        }
        throw new BadCredentialsException("El usuario o código OTP es incorrecto");
    }

    @Override
    public boolean supports(Class<?> authentication) {
        return OtpAuthentication.class.isAssignableFrom(authentication);
    }
}
````

## [Pág. 274] Implementación de los filtros

En esta sección, implementamos los filtros personalizados para agregar a la cadena de filtros. **Su propósito** es
**interceptar solicitudes y aplicar lógica de autenticación.** Elegimos implementar un filtro para tratar con la
autenticación realizada por el servidor de autenticación y otro para la autenticación basada en JWT.

Implementamos una clase **InitialAuthenticationFilter**, que se ocupa de los primeros pasos de autenticación que se
realizan utilizando el servidor de autenticación.

En el primer paso, el usuario se autentica con su nombre de usuario y contraseña para recibir una OTP.
También vio estos gráficos en las figuras 11.11 y 11.12, pero los agrego de nuevo para que no tenga que volver atrás en
las páginas y buscarlos.

![first-authentication-step](./assets/first-authentication-step.png)

En el segundo paso, el usuario envía la OTP para demostrar que realmente es quien dice ser y, luego de una autenticación
exitosa, la aplicación le proporciona un token para llamar a cualquier punto final expuesto por el servidor de lógica de
negocios.

![second-authentication-step-otp](./assets/second-authentication-step-otp.png)

El listado 11.21 presenta la definición de la clase InitialAuthenticationFilter. **Comenzamos inyectando el
AuthenticationManager al que delegamos la responsabilidad de la autenticación**, **anulamos el
método doFilterInternal()**, que se llama cuando la solicitud llega a este filtro en la cadena de filtros, y **anulamos
el método shouldNotFilter().** Como discutimos en el capítulo 9, **el método shouldNotFilter()** es una de las razones
por las que elegiríamos extender la clase OncePerRequestFilter en lugar de implementar la interfaz Filter directamente.
**Cuando anulamos este método**, definimos una condición específica sobre **cuándo se ejecutan los filtros.** En nuestro
caso, queremos **ejecutar cualquier solicitud solo en la ruta /login y omitir todas las demás.**

Seguimos escribiendo la clase InitialAuthenticationFilter con el **primer paso de autenticación**, aquel en el que **el
cliente envía el usuario y la contraseña para obtener la OTP**. Suponemos que si el usuario no envía una OTP (un
código), tenemos que hacer una autenticación basada en el nombre de usuario y la contraseña. Tomamos todos los valores
del encabezado de la solicitud HTTP donde esperamos que estén, y si no se envió un código, llamamos al primer paso de
autenticación creando una instancia de UsernamePasswordAuthentication (listado 11.22) y reenviando la responsabilidad al
AuthenticationManager.

Sabemos (desde el capítulo 2) que a continuación, **el AuthenticationManager intenta encontrar un AuthenticationProvider
adecuado**. **En nuestro caso, este es el UsernamePasswordAuthenticationProvider** que escribimos en el listado 11.19.
**Es el que se activa porque su método support() indica que acepta el tipo UsernamePasswordAuthentication.**

Sin embargo, si se envía un código en la solicitud, asumimos que es el segundo paso de autenticación. En este caso,
creamos un objeto OtpAuthentication para llamar al AuthenticationManager (listado 11.23). Sabemos por nuestra
implementación de la clase OtpAuthenticationProvider en el listado 11.20 que si la autenticación falla, se genera una
excepción. Esto significa que el token JWT se generará y adjuntará a los encabezados de respuesta HTTP solo si la OTP es
válida.

Si observamos el código, veremos un fragmento de código crea el JWT. Utilizo el método setClaims() para agregar un valor
en el cuerpo de JWT y el método signWith() para adjuntar una firma al token. Para nuestro ejemplo, **uso una clave
simétrica para generar la firma.**

Esta clave solo la conoce el servidor de lógica de negocio. El servidor de lógica de negocio firma el token y puede
usar la misma clave para validar el token cuando el cliente llama a un punto final. Para simplificar el ejemplo, aquí
uso una clave para todos los usuarios. Sin embargo, en un escenario del mundo real, tendría una clave diferente para
cada usuario, pero como ejercicio, puede cambiar esta aplicación para usar claves diferentes. La ventaja de usar claves
individuales para los usuarios es que si necesita invalidar todos los tokens para un usuario, solo necesita cambiar su
clave.

Debido a que inyectamos el valor de la clave utilizada para firmar el JWT desde las propiedades, debemos cambiar el
archivo application.properties para definir este valor. En nuestro caso, en el archivo application.properties ya
configuramos anteriormente la clave que usaremos.

Como un último comentario, en la declaración del atributo ``authenticationManager`` agregamos la anotación ``@Lazy``.
Esta anotación no está en el código de este libro (Spring Security In Action) pero nosotros lo agregamos, ya que al
ejecutar el proyecto nos lanzaba el error de ``dependencias cícliclas`` entre la clase ``InitialAuthenticationFilter``
y la clase ``SecurityConfig``. La clase SecurityConfig expone el bean del AuthenticationManager, además esta clase
inyecta a la clase InitialAuthenticationFilter, y la clase InitialAuthenticationFilter inyecta al AuthenticationManager
que es expuesto en la clase SecurityConfig, produciéndose de esta manera la dependencia cíclica. Entonces, una forma
de resolver dicha dependencia cíclica es usando la anotación ``@Lazy``, siempre y cuando no se pueda modificar el
código, en caso sí se pueda, es preferible modificar el código a fin de buscar romper la dependencia cíclica.

[**Uso de @Lazy**](https://www.baeldung.com/circular-dependencies-in-spring)

> Una forma sencilla de romper el ciclo es diciéndole a Spring que **inicialice uno de los Bean perezosamente.**
> Entonces, en lugar de inicializar completamente el bean, creará un proxy para inyectarlo en el otro bean. El bean
> inyectado solo se creará completamente cuando se necesite por primera vez. (Fuente. Baeldung)

````java

@Component
public class InitialAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    @Lazy
    private AuthenticationManager authenticationManager;
    @Value("${jwt.signing.key}")
    private String signinKey;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String username = request.getHeader("username");
        String password = request.getHeader("password");
        String code = request.getHeader("code");

        if (code == null) {
            Authentication authentication = new UsernamePasswordAuthentication(username, password);
            this.authenticationManager.authenticate(authentication);
        } else {
            Authentication authentication = new OtpAuthentication(username, code);
            this.authenticationManager.authenticate(authentication);

            SecretKey key = Keys.hmacShaKeyFor(this.signinKey.getBytes(StandardCharsets.UTF_8));
            String jwt = Jwts.builder()
                    .setClaims(Map.of("username", username))
                    .signWith(key)
                    .compact();
            response.setHeader("Authorization", jwt);
        }
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
        return !request.getServletPath().equals("/login");
    }
}
````

También debemos agregar el filtro que se ocupa de las solicitudes en todas las rutas que no sean /login. Llamo a este
filtro **JwtAuthenticationFilter**. Este filtro espera que exista un JWT en el encabezado HTTP de autorización de la
solicitud. Este filtro valida el JWT comprobando la firma, **crea un objeto autenticado Authentication** y **lo agrega a
SecurityContext.** La siguiente lista presenta la implementación de JwtAuthenticationFilter.

````java

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    @Value("${jwt.signing.key}")
    private String signinKey;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String jwt = request.getHeader("Authorization");

        SecretKey key = Keys.hmacShaKeyFor(this.signinKey.getBytes(StandardCharsets.UTF_8));
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(jwt)
                .getBody();

        String username = String.valueOf(claims.get("username"));

        GrantedAuthority grantedAuthority = new SimpleGrantedAuthority("user");
        Authentication auth = new UsernamePasswordAuthentication(username, null, List.of(grantedAuthority));
        SecurityContextHolder.getContext().setAuthentication(auth);

        filterChain.doFilter(request, response);
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
        return request.getServletPath().equals("/login");
    }
}
````

**NOTA**

> Un JWT firmado también se denomina JWS (JSON Web Token Signed). Es por eso que el nombre del método que usamos es
> parseClaimsJws().

## Escribiendo las configuraciones de seguridad

Tenemos que hacer unas cuantas configuraciones para que todo lo desarrollado hasta ahora sea coherente:

1. Agregue los filtros a la cadena de filtros como aprendió en el capítulo 9.
2. Deshabilite la protección CSRF porque, como aprendió en el capítulo 10, esto no se aplica cuando se usan diferentes
   orígenes. Aquí, usar un JWT reemplaza la validación que se haría con un token CSRF.
3. Agregue los objetos AuthenticationProvider para que AuthenticationManager los conozca.
4. Use métodos matcher para configurar todas las solicitudes que necesitan ser autenticadas, como aprendió en el
   capítulo 8.
5. **Agregue el bean AuthenticationManager en el contexto de Spring** para que podamos inyectarlo desde la clase
   InitialAuthenticationFilter, como vio en el listado 11.23.

````java

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private InitialAuthenticationFilter initialAuthenticationFilter;
    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;
    @Autowired
    private OtpAuthenticationProvider otpAuthenticationProvider;
    @Autowired
    private UsernamePasswordAuthenticationProvider usernamePasswordAuthenticationProvider;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(this.otpAuthenticationProvider)
                .authenticationProvider(this.usernamePasswordAuthenticationProvider);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();

        http.addFilterAt(this.initialAuthenticationFilter, BasicAuthenticationFilter.class)
                .addFilterAfter(this.jwtAuthenticationFilter, BasicAuthenticationFilter.class);

        http.authorizeRequests().anyRequest().authenticated();
    }

    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }
}
````

## Probando todo el sistema

- Debemos ejecutar ambos proyectos: **servidor de autenticación** y **servidor de lógica de negocio**.
- Debemos tener creado en la base de datos al menos un usuario para hacer las pruebas. Recordemos que nosotros
  creamos en la sección donde creamos el servidor de autenticación un usuario llamado **admin** cuyo pass es **12345**,
  si no tenemos ningún usuario, sencillamente usando los endpoints del servidor de autenticación nos creamos uno.

1. **Primer paso del login: usuario y password**: como resultado, en la base de datos se almacenará un OTP para este
   usuario. En el mundo real, dicho código OTP deberá ser enviado vía SMS al usuario.

````bash
curl -v -H "username:admin" -H "password:12345" http://localhost:9090/login

--- Respuesta ---
< HTTP/1.1 200
< Date: Thu, 08 Jun 2023 16:49:08 GMT
<
* Connection
````

````
username: admin
otp: 3113
````

2. **Segundo paso del login: usuario y code otp**: ingresando el usuario y el otp generado en el paso anterior, nos
   retornará en el Header de la respuesta el JWT que usaremos para hacer peticiones a los endpoints del servidor de
   lógica de negocio.

````bash
curl -v -H "username:admin" -H "code:3113" http://localhost:9090/login

--- Respuesta ---
< HTTP/1.1 200
< Authorization: eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.u7HCVGBOPJuuouFBmtB-3YEqVW8jSeOjIvNTYEdBwrI
< Date: Thu, 08 Jun 2023 16:53:42 GMT
<
* Connection
````

3. **Tercer paso: acceder al endpoint /test**: El jwt obtenido en el paso anterior nos servirá para acceder a los
   endpoints del servidor de lógica de negocio, ahora, el acceso va a depender de los authorities del usuario o la
   configuración de los endpoints.

````bash
curl -v -H "Authorization: eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.u7HCVGBOPJuuouFBmtB-3YEqVW8jSeOjIvNTYEdBwrI" http://localhost:9090/test

--- Respuesta ---
< HTTP/1.1 200
< Set-Cookie: JSESSIONID=10B5AACA112F288244B521BD5152B1CE; Path=/; HttpOnly
< Date: Thu, 08 Jun 2023 16:56:47 GMT
<
Test!
````