# [Pág. 244] Capítulo 11 - Manos a la obra: una separación de responsabilidades

En este capítulo, diseñaremos un sistema de tres actores: **el cliente, el servidor de autenticación y el servidor de
lógica empresarial.** A partir de estos tres actores, implementaremos la parte de backend del servidor de autenticación
y un servidor de lógica empresarial.

## El escenario y los requisitos del ejemplo

La arquitectura del sistema que diseñaremos tiene tres componentes:

- **El cliente**: esta es la aplicación que consume el backend. Podría ser una aplicación móvil o la interfaz de una
  aplicación web desarrollada con un framework como Angular, ReactJS o Vue.js. No implementamos la parte del cliente del
  sistema, pero tenga en cuenta que existe en una aplicación del mundo real. En lugar de usar el cliente para llamar a
  los puntos finales, usamos cURL.
- **El servidor de autenticación**: esta es una aplicación con una base de datos de credenciales de usuario. El
  propósito de esta aplicación es autenticar a los usuarios en función de sus credenciales (nombre de usuario y
  contraseña) y enviarles una contraseña de un solo uso (OTP) a través de SMS. Debido a que en realidad no enviaremos un
  SMS en este ejemplo, leeremos el valor de la OTP directamente desde la base de datos. En este capítulo, implementamos
  toda esta aplicación sin enviar el SMS.
- **El servidor de lógica empresarial**: esta es la aplicación que expone los endpoints que consume nuestro cliente.
  Queremos asegurar el acceso a estos endpoints. Antes de llamar a un endpoint el usuario debe autenticarse con su
  nombre de usuario y contraseña y luego enviar una OTP. El usuario recibe la OTP a través de un mensaje SMS. Debido a
  que esta aplicación es nuestra aplicación de destino, la protegeremos con Spring Security.

![hands-on_a-separation-of-responsibilities-escenario-1](./assets/hands-on_a-separation-of-responsibilities-escenario-1.png)

Para llamar a cualquier punto final en el servidor de lógica de negocios, el cliente debe seguir tres pasos:

1. Autenticar el nombre de usuario y la contraseña llamando al punto final /login en el servidor de lógica de negocios
   para obtener una OTP generada aleatoriamente.
2. Llame al punto final /login con el nombre de usuario y OTP.
3. Llame a cualquier endpoint agregando el token recibido en el paso 2 al encabezado de Autorización de la solicitud
   HTTP.

Cuando el cliente autentica el nombre de usuario y la contraseña, el servidor de lógica de negocio envía una solicitud
de OTP al servidor de autenticación. Después de una autenticación exitosa, el servidor de autenticación envía una OTP
generada aleatoriamente al cliente a través de SMS. **Esta forma de identificar al usuario se llama
autenticación multifactor (MFA)**, y es bastante común hoy en día. Por lo general, necesitamos que los usuarios
demuestren quiénes son usando sus credenciales y con otro medio de identificación (por ejemplo, que poseen un
dispositivo móvil específico).

![first-step-authentication](./assets/first-step-authentication.png)

En el segundo paso de autenticación, una vez que el cliente tiene el código del SMS recibido, el usuario puede llamar al
punto final /login, nuevamente con el nombre de usuario y el código. El servidor de lógica empresarial valida el código
con el servidor de autenticación. Si el código es válido, el cliente recibe un token que puede usar para llamar a
cualquier punto final en el servidor de lógica de negocio.

![Second-authentication-step](./assets/Second-authentication-step.png)

En el tercer paso de autenticación, el cliente ahora puede llamar a cualquier endpoint agregando el token que recibió en
el paso 2 al encabezado de Autorización de la solicitud HTTP.

![third-authentication-step](./assets/third-authentication-step.png)

**NOTA**

> Este ejemplo nos permite trabajar en una aplicación más grande, que incluye más de los conceptos que discutimos en
> capítulos anteriores. Para permitirle concentrarse en los conceptos de Spring Security que quiero incluir en la
> aplicación, simplifico la arquitectura del sistema. Alguien podría argumentar que esta arquitectura utiliza enfoques
> viciosos ya que el cliente solo debe compartir contraseñas con el servidor de autenticación y nunca con el servidor de
> lógica empresarial. ¡Esto es correcto! En nuestro caso, es solo una simplificación. En escenarios del mundo real, en
> general, nos esforzamos por mantener las credenciales y los secretos conocidos por la menor cantidad posible de
> componentes en el sistema. Además, alguien podría argumentar que el escenario MFA en sí mismo podría implementarse más
> fácilmente mediante el uso de un sistema de administración de terceros como Okta o algo similar. Parte del propósito
> del ejemplo es enseñarle cómo definir filtros personalizados. Por esta razón, elegí la forma difícil de implementar,
> nosotros mismos, esta parte de la arquitectura de autenticación.

## [Pág. 248] Implementación y uso de tokens

Una aplicación obtiene un token como resultado del proceso de autenticación y para acceder a los recursos. Los puntos
finales representan los recursos en una aplicación web. Para una aplicación web, un token es una cadena, generalmente
enviada a través de un encabezado HTTP por clientes que desean acceder a un punto final en particular. Esta cadena puede
ser simple como un identificador único universal (UUID) puro, o puede tener una forma más compleja como un token web
JSON (JWT).

**¿Qué es un token?**, los tokens proporcionan un método que utiliza una aplicación para demostrar que ha autenticado a
un usuario, lo que le permite acceder a los recursos de la aplicación.

**¿Qué es un JWT?**

* **JSON**, utiliza JSON para formatear los datos que contiene.
* **Web**, está diseñado para ser utilizado para solicitudes web.
* **Token**, es una implementación de token.

JWT es una implementación de token. Agrega el beneficio de transferir datos fácilmente durante la autenticación, así
como firmar datos para validar su integridad.

![JWT-parts.png](./assets/JWT-parts.png)

En este capítulo, usaremos [Java JSON Web Token (JJWT)](https://github.com/jwtk/jjwt#overview) como biblioteca para
crear y analizar JWT. Esta es una de las bibliotecas más utilizadas para generar y analizar tokens JWT en aplicaciones
Java.

## [Pág. 253] Implementando el servidor de autenticación

El código fuente está en el siguiente
repositorio: [spring-security-in-action-2020-cap-11-authentication-server](https://github.com/magadiflo/spring-security-in-action-2020-cap-11-authentication-server.git)

En esta sección, comenzamos la implementación de nuestro ejemplo práctico. **La primera dependencia que tenemos es el
servidor de autenticación.** Incluso si no es la aplicación en la que nos enfocamos al usar Spring Security, la
necesitamos para nuestro resultado final.

En nuestro escenario, el servidor de autenticación se conecta a una base de datos donde almacena las credenciales de
usuario y las OTP generadas durante los eventos de autenticación de solicitudes. Necesitamos esta aplicación para
exponer tres endpoints.

- **/user/add**, agrega un usuario que usaremos más tarde para probar nuestra implementación.
- **/user/auth**, autentica a un usuario por sus credenciales y envía un SMS con una OTP. Quitamos la parte que envía el
  SMS, pero esto lo puedes hacer como ejercicio.
- **/otp/check**, verifica que un valor OTP sea el que el servidor de autenticación generó anteriormente para un usuario
  específico.

![class-design-for-an-authentication-server](./assets/class-design-for-an-authentication-server.png)

Las dependencias a usar para esta versión de Spring Boot 2.6.4:

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el archivo application.properties, proporcionamos los parámetros que necesita Spring Boot para crear el Data source.
El siguiente fragmento de código muestra el contenido del archivo application.properties:

````properties
# Datasource MySQL
spring.datasource.url=jdbc:mysql://localhost:3306/db_spring_security_in_action_2020?serverTimezone=America/Lima
spring.datasource.username=root
spring.datasource.password=magadiflo
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# Configurando dialecto a MySQL
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
# Generar tablas: create, crea el esquema y destruye los datos previos
spring.jpa.hibernate.ddl-auto=create
# Vista y formato en el log
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
````

La clase de configuración para el servidor de autenticación:

- Deshabilite CSRF para que podamos llamar a todos los puntos
  finales de la aplicación directamente.
- Permite todas las llamadas sin autenticación.

````java

@Configuration
public class ProjectConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();
        http.authorizeRequests().anyRequest().permitAll();
    }
}
````

Definimos un codificador de contraseñas para codificar las contraseñas almacenadas en la base de datos:

````java

@Configuration
public class UserManagementConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

}
````

Las entidades que participan en la autenticación:

````java

@Entity
@Table(name = "users")
public class User {
    @Id
    private String username;
    private String password;

    /* setters, getters and toString() */
}
````

````java

@Entity
@Table(name = "otps")
public class Otp {
    @Id
    private String username;
    private String code;

    /* setters, getters and toString() */
}
````

Los repositorios asociados a cada entity:

````java
public interface UserRepository extends JpaRepository<User, String> {
    Optional<User> findUserByUsername(String username);
}
````

````java
public interface OtpRepository extends JpaRepository<Otp, String> {
    Optional<Otp> findOtpByUsername(String username);
}
````

Con los repositorios y las entidades en su lugar, podemos trabajar en la lógica de la aplicación. Para esto, creo una
clase de servicio que llamo UserService. Como se muestra en el siguiente código, el servicio tiene dependencias en los
repositorios y el codificador de contraseñas. Debido a que usamos estos objetos para implementar la lógica de la
aplicación, necesitamos autoconectarlos.

````java

@Service
@Transactional
public class UserService {
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private OtpRepository otpRepository;

    public void addUser(User user) {
        user.setPassword(this.passwordEncoder.encode(user.getPassword()));
        this.userRepository.save(user);
    }

    public void auth(User user) {
        Optional<User> optionalUserDB = this.userRepository.findUserByUsername(user.getUsername());
        if (optionalUserDB.isPresent()) {
            User userDB = optionalUserDB.get();
            if (this.passwordEncoder.matches(user.getPassword(), userDB.getPassword())) {
                this.renewOtp(userDB);
            } else {
                throw new BadCredentialsException("Credenciales incorrectos! El password no hace match!");
            }
        } else {
            throw new BadCredentialsException("Credenciales incorrectos! El username " + user.getUsername() + " no existe!");
        }
    }

    public boolean check(Otp otpToValidate) {
        Optional<Otp> otpByUsername = this.otpRepository.findOtpByUsername(otpToValidate.getUsername());
        if (otpByUsername.isPresent()) {
            Otp otpDB = otpByUsername.get();
            return otpToValidate.getCode().equals(otpDB.getCode());
        }
        return false;
    }

    private void renewOtp(User user) {
        String code = GenerateCodeUtil.generateCode();
        Optional<Otp> optionalUserOtpDB = this.otpRepository.findOtpByUsername(user.getUsername());

        if (optionalUserOtpDB.isPresent()) {
            Otp otpDB = optionalUserOtpDB.get();
            otpDB.setCode(code);
        } else {
            Otp otp = new Otp();
            otp.setUsername(user.getUsername());
            otp.setCode(code);
            this.otpRepository.save(otp);
        }
    }
}
````

El siguiente código presenta la clase GenerateCodeUtil. Usamos esta clase para generar el nuevo valor OTP.

````java
public class GenerateCodeUtil {
    private GenerateCodeUtil() {
    }

    public static String generateCode() {
        String code;
        try {
            SecureRandom random = SecureRandom.getInstanceStrong();
            code = String.valueOf(random.nextInt(9000) + 1000);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Problemas al generar el código aleatorio!!!");
        }
        return code;
    }
}
````

Finalmente, en esta aplicación exponemos la lógica presentada con un controlador. La siguiente lista define este
controlador:

````java

@RestController
public class AuthController {
    @Autowired
    private UserService userService;

    @PostMapping(path = "/user/add")
    public void addUser(@RequestBody User user) {
        this.userService.addUser(user);
    }

    @PostMapping(path = "/user/auth")
    public void auth(@RequestBody User user) {
        this.userService.auth(user);
    }

    @PostMapping(path = "/otp/check")
    public void check(@RequestBody Otp otp, HttpServletResponse response) {
        if (this.userService.check(otp)) {
            response.setStatus(HttpServletResponse.SC_OK);
        } else {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        }
    }
}

````

Con esta configuración, ahora tenemos el servidor de autenticación. Comencemos y asegurémonos de que los puntos finales
funcionen de la manera que esperamos. Para probar la funcionalidad del servidor de autenticación, necesitamos:

1. Agregue un nuevo usuario a la base de datos llamando al punto final /user/add.
2. Valide que el usuario se agregó correctamente al verificar la tabla de usuarios en la base de datos.
3. Llame al punto final /user/auth para el usuario agregado en el paso 1.
4. Validar que la aplicación genere y almacene una OTP en la tabla otp.
5. Use la OTP generada en el paso 3 para validar que el punto final /otp/check funciona como se desea.

- Agregando un nuevo usuario

````bash
curl -v -X POST -H "content-type: application/json" -d "{\"username\":\"admin\", \"password\": \"12345\"}" http://localhost:8080/user/add

-- Respuesta ---
< HTTP/1.1 200
<
* Connection #0 to host localhost left intact
````

- Generemos una OTP para el usuario llamado al endpoint /user/auth

````bash
curl -v -X POST -H "content-type: application/json" -d "{\"username\":\"admin\", \"password\": \"12345\"}" http://localhost:8080/user/auth

--- Respuesta ---
< HTTP/1.1 200
<
* Connection #0 to host localhost left intact
````

- El último paso para probar nuestro servidor de autenticación es llamar al extremo /otp/check y verificar que devuelve
  un código de estado HTTP 200 OK en la respuesta cuando la OTP es correcta y 403 Forbidden si el OTP está mal.

````bash
--- Código OTP existente ---
curl -v -X POST -H "content-type: application/json" -d "{\"username\":\"admin\", \"code\": \"7699\"}" http://localhost:8080/otp/check

--- Respuesta ---
< HTTP/1.1 200
<
* Connection #0 to host localhost left intact
````

````bash
--- Código OTP no existente ---
curl -v -X POST -H "content-type: application/json" -d "{\"username\":\"admin\", \"code\": \"8877\"}" http://localhost:8080/otp/check

--- Respuesta ---
< HTTP/1.1 403
<
* Connection #0 to host localhost left intact
````

**¡Acabamos de demostrar que los componentes del servidor de autenticación funcionan!**

Ahora podemos sumergirnos en el siguiente elemento para el que escribimos la mayoría de las configuraciones de Spring
Security para nuestro ejemplo práctico actual: **el servidor de lógica de negocio.**

---

## [Pág. 263] Implementando el servidor de lógica de negocio

El código fuente estará en el siguiente repositorio: [spring-security-in-action-2020-cap-11-business-logic-server]

En esta sección, implementamos el servidor de lógica de negocios. Con esta aplicación, reconocerá muchas de las cosas
que discutimos hasta este punto en el libro. Con esta parte del sistema, **aprenderá a implementar y
utilizar JWT para autenticación y autorización.** Además, implementamos la comunicación entre el servidor de lógica
de negocio y el servidor de autenticación para establecer la autenticación de múltiples factores (MFA) en su aplicación.

Para llevar a cabo nuestra tarea, a un alto nivel, necesitamos:

1. Cree un endpoint que represente el recurso que queremos proteger.
2. Implemente el primer paso de autenticación en el que el cliente envía las credenciales de usuario (nombre de usuario
   y contraseña) al servidor de lógica de negocio para iniciar sesión.
3. Implemente el segundo paso de autenticación en el que el cliente envía la OTP que el usuario recibe del servidor de
   autenticación al servidor de lógica de negocio. Una vez autenticado por la OTP, el cliente obtiene un JWT, que puede
   usar para acceder a los recursos de un usuario.
4. Implementar la autorización basada en el JWT. El servidor de lógica de negocio valida el JWT recibido de un cliente
   y, si es válido, permite que el cliente acceda al recurso.

Empezamos con las dependencias. La siguiente lista muestra las dependencias que necesita agregar al archivo pom.xml.
Recordar que estamos usando Spring Boot 2.6.4 y Java 17:

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- Dependencias de jjwt para generar y analizar JWT -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.11.1</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.11.1</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.11.1</version>
        <scope>runtime</scope>
    </dependency>
    <!-- Necesitamos esto si usamos Java 10 o superior -->
    <dependency>
        <groupId>jakarta.xml.bind</groupId>
        <artifactId>jakarta.xml.bind-api</artifactId>
    </dependency>
    <dependency>
        <groupId>org.glassfish.jaxb</groupId>
        <artifactId>jaxb-runtime</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En esta aplicación, solo definimos un punto final /test. Todo lo demás que escribimos en este proyecto es para asegurar
este punto final. El punto final /test está expuesto por la clase TestController, que se presenta en la siguiente lista.

````java

@RestController
public class TestController {
    @GetMapping(path = "/test")
    public String test() {
        return "Test!";
    }
}
````

Para asegurar la aplicación ahora, tenemos que definir los tres niveles de autenticación:

1. Autenticación con usuario y contraseña para recibir una OTP:

![first-authentication-step](./assets/first-authentication-step.png)

2. Autenticación con OTP para recibir un token:

![second-authentication-step-otp](./assets/second-authentication-step-otp.png)

3. Autenticación con el token para acceder al endpoint:

![last-authentication-step](./assets/last-authentication-step.png)

Con los requisitos dados para este ejemplo, que es más complejo y supone varios pasos de autenticación, la autenticación
HTTP basic ya no puede ayudarnos. Necesitamos implementar filtros especiales y proveedores de autenticación para
personalizar la lógica de autenticación para nuestro escenario. Afortunadamente, aprendió a definir filtros
personalizados en el capítulo 9, así que revisemos la arquitectura de autenticación en Spring Security:

![authentication-architecture-spring-security](./assets/authentication-architecture-spring-security.png)

A menudo, al desarrollar una aplicación, hay más de una buena solución. Al diseñar una arquitectura, siempre debe pensar
en todas las implementaciones posibles y elegir la que mejor se adapte a su escenario. Si se aplica más de una opción y
no puede decidir cuál es la mejor para implementar, debe escribir una prueba de concepto para cada opción para ayudarlo
a decidir qué solución elegir. **Para nuestro escenario**, presento **dos opciones**, y luego **continuamos la
implementación con una de estas.** Dejo la otra opción como un ejercicio para que usted lo implemente.

La primera opción para nosotros es definir tres objetos de autenticación personalizados, **tres objetos
AuthenticationProvider personalizados** y **un filtro personalizado** para **delegar** a estos **mediante el uso de
AuthenticationManager**. Aprendió a implementar las interfaces Authentication y AuthenticationProvider en
el capítulo 5.

![first-option](./assets/first-option.png)

La segunda opción, que elegí implementar en este ejemplo, es tener dos objetos Authentication personalizados y dos
objetos AuthenticationProvider personalizados. Estos objetos pueden ayudarnos a aplicar la lógica relacionada con el
punto final /login:

- Autenticar al usuario con usuario y contraseña
- Autenticar al usuario con un OTP

Luego implementamos la validación del token con un segundo filtro. La figura 11.16 presenta este enfoque:

![second-option](./assets/second-option.png)

Ambos enfoques son igualmente buenos. Describo ambos solo para ilustrar que puede encontrar casos en los que tiene
varias formas de desarrollar el mismo escenario, especialmente porque Spring Security ofrece una arquitectura bastante
flexible.

**El autor del libro eligió el segundo** porque ofrece la posibilidad de resumir más cosas, como tener múltiples filtros
personalizados y usar el método shouldNotFilter() de la clase OncePerRequestFilter. Discutimos brevemente esta clase en
la sección 9.5, pero no tuve la oportunidad de aplicar el método shouldNotFilter() con un ejemplo. Aprovechamos esta
oportunidad ahora.

## Implementación de los objetos de autenticación

En esta sección, implementamos los dos objetos de autenticación que necesitamos para que nuestra solución desarrolle el
servidor de lógica empresarial. Al comienzo de la sección 11.4, creamos el proyecto y agregamos las dependencias
necesarias. También creamos un punto final que queremos proteger y decidimos cómo implementar el diseño de clase para
nuestro ejemplo. **Necesitamos dos tipos de objetos de autenticación**, uno para representar la **autenticación por
nombre de usuario y contraseña** y un segundo para representar la **autenticación por OTP**. Como aprendió en el
capítulo 5, **el contrato de autenticación representa el proceso de autenticación de una solicitud.**
Puede ser un proceso en curso o después de su finalización. Necesitamos implementar la interfaz de Autenticación tanto
para los casos en los que la aplicación autentica al usuario con su nombre de usuario y contraseña, como para una OTP.

En el listado 11.14, encontrará la clase UsernamePasswordAuthentication, que implementa la autenticación con nombre de
usuario y contraseña. Para acortar las clases, extiendo la clase UsernamePasswordAuthenticationToken e, indirectamente,
la interfaz de autenticación. Viste la clase UsernamePasswordAuthenticationToken en el capítulo 5, donde analizamos la
aplicación de una lógica de autenticación personalizada.

````java
public class UsernamePasswordAuthentication extends UsernamePasswordAuthenticationToken {
    public UsernamePasswordAuthentication(Object principal, Object credentials) {
        super(principal, credentials);
    }

    public UsernamePasswordAuthentication(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities) {
        super(principal, credentials, authorities);
    }
}
````

Tenga en cuenta que defino ambos constructores en esta clase. Hay una gran diferencia entre estos:

- **cuando llama al que tiene dos parámetros**, la instancia de autenticación permanece sin autenticar.
- **mientras el que tiene tres parámetros establece el objeto de autenticación como autenticado.**

Como aprendió en el capítulo 5, **cuando se autentica la instancia de Autenticación, significa que el proceso de
autenticación finaliza.** Si el objeto de autenticación no está configurado como autenticado y no se genera ninguna
excepción durante el proceso, AuthenticationManager intenta encontrar un objeto AuthenticationProvider adecuado para
autenticar la solicitud.

Usamos el constructor con dos parámetros cuando construimos inicialmente el objeto de autenticación y aún no está
autenticado. Cuando un objeto AuthenticationProvider autentica la solicitud, crea una instancia de autenticación
utilizando el constructor con tres parámetros, lo que crea un objeto autenticado. El tercer parámetro es la colección de
autorizaciones otorgadas, que es obligatoria para un proceso de autenticación que ha finalizado.

De manera similar a UsernamePasswordAuthentication, implementamos el segundo objeto de autenticación para el segundo
paso de autenticación con OTP. Llamo a esta clase OtpAuthentication. El listado 11.15 demuestra que la clase extiende el
UsernamePasswordAuthenticationToken. Podemos usar la misma clase porque tratamos la OTP como una contraseña. Debido a
que es similar, usamos el mismo enfoque para guardar algunas líneas de código.

````java
public class OtpAuthentication extends UsernamePasswordAuthenticationToken {
    public OtpAuthentication(Object principal, Object credentials) {
        super(principal, credentials);
    }

    public OtpAuthentication(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities) {
        super(principal, credentials, authorities);
    }
}

````
