# [Pág. 86] Capítulo 04 - Tratando con contraseñas

## [Pág. 87] La definición de la interfaz PasswordEncoder

Implementa este contrato para decirle a Spring Security **cómo validar la contraseña de un usuario.** En el proceso
de autenticación, **PasswordEncoder** decide si una contraseña es válida o no. El PasswordEncoder también puede
codificar contraseñas. ``Los métodos encode() y matches(), que declara el contrato, son en realidad la definición
de su responsabilidad``.

A continuación se muestra el contenido de la interfaz PasswordEncoder:

````java
public interface PasswordEncoder {

    String encode(CharSequence rawPassword);

    boolean matches(CharSequence rawPassword, String encodedPassword);

    default boolean upgradeEncoding(String encodedPassword) {
        return false;
    }

}
````

**DONDE:**

- El método **encode(...)** devuelve una transformación de una cadena proporcionada. En cuando a la funcionalidad
  de Spring Security, se usa para proporcionar cifrado o un hash para una contraseña determinada.
- El método **matches(...)**, verifica si una cadena codificada coincide con una contraseña sin formato.
- El método por default **upgradeEncoding(...)**, por defecto es falso en la interfaz. Si lo anula para que devuelva
  verdadero, la contraseña codificada se vuelve a codificar para mayor seguridad.

## [Pág. 88] Implementando la interfaz PasswordEncoder

Si implementamos la interfaz PasswordEncoder y anulamos sus dos métodos abstractos, estos siempre deben corresponderse
en términos de funcionalidad: **una cadena devuelta por el método encode() siempre debe ser verificable con el método
matches() del mismo PasswordEncoder.**

La implementación más simple del PasswordEncoder es que no realice ninguna codificación de la contraseña, es decir
la devuelva en texto plano, precisamente esa es la funcionalidad de la instancia de **NoOpPasswordEncoder** que usamos
en capítulos anteriores. A continuación se muestra nuestra propia implementación sin ninguna encriptación:

````java
public class PlainTextPasswordEncoder implements PasswordEncoder {

    @Override
    public String encode(CharSequence rawPassword) {
        return rawPassword.toString();
    }

    @Override
    boolean matches(CharSequence rawPassword, String encodedPassword) {
        return rawPassword.equals(encodedPassword);
    }

}
````

## [Pág. 90] Elegir entre las implementaciones proporcionadas del PasswordEncoder

Si bien saber cómo implementar su PasswordEncoder es poderoso, también debe tener en cuenta que Spring Security ya le
brinda algunas implementaciones ventajosas:

- **NoOpPasswordEncoder**, Doesn’t encode the password but keeps it in cleartext. We use this implementation only for
  examples. Because it doesn’t hash the password, you should never use it in a real-world scenario.
- **StandardPasswordEncoder**, Utiliza SHA-256 para cifrar la contraseña. Esta implementación ahora está obsoleta y no
  debe usarla para sus nuevas implementaciones. La razón por la que está en desuso es que utiliza un algoritmo hash que
  ya no consideramos lo suficientemente fuerte, pero aún puede encontrar esta implementación en aplicaciones existentes.
- **Pbkdf2PasswordEncoder**, utiliza la función de derivación de clave basada en contraseña 2 (PBKDF2).
- **BCryptPasswordEncoder**, utiliza una función hash fuerte de bcrypt para codificar la contraseña.
- **SCryptPasswordEncoder**, utiliza una función hash scrypt para codificar la contraseña.

Una de las excelentes opciones que ofrece Spring Security es **BCryptPasswordEncoder**, que utiliza una función hash
fuerte de bcrypt para codificar la contraseña. Puede crear instancias de BCryptPasswordEncoder llamando al constructor
sin argumentos. Pero también tiene la **opción de especificar un coeficiente de fuerza** que represente las log
logarítmicas (rondas logarítmicas) utilizadas en el proceso de codificación (**por defecto**, si no se especifica el
coeficiente de fuerza su valor **es 10**). Además, **también puede filtrar la instancia de SecureRandom utilizada para
codificar**:

````
  PasswordEncoder p = new BCryptPasswordEncoder();
  PasswordEncoder p = new BCryptPasswordEncoder(4);

  SecureRandom s = SecureRandom.getInstanceStrong();
  PasswordEncoder p = new BCryptPasswordEncoder(4, s);
````