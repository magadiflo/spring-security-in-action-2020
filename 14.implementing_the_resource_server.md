# [Pág. 338] Capítulo 14 - OAuth 2: Implementación del servidor de recursos

**El servidor de recursos es el componente que gestiona los recursos de los usuarios.** El nombre servidor de recursos
puede no ser sugerente para empezar, pero **en términos de OAuth 2, representa el backend que protege** como cualquier
otra aplicación que aseguramos en los capítulos anteriores.

¿Recuerda, por ejemplo, el servidor de lógica empresarial que implementamos en el capítulo 11? Para permitir que un
cliente acceda a los recursos, el servidor de recursos requiere un token de acceso válido. Un cliente obtiene un token
de acceso del servidor de autorización y lo usa para solicitar recursos en el servidor de recursos agregando el token a
los encabezados de solicitud HTTP. La figura 14.1 proporciona un repaso del capítulo 12, que muestra el lugar del
servidor de recursos en la arquitectura de autenticación OAuth 2.

![figure-14-1](./assets/figure-14-1.png)

En este capítulo, aprenderá a implementar el servidor de recursos. Pero lo que es más importante **cuando se habla de la
implementación del servidor de recursos es elegir cómo el servidor de recursos valida los tokens.** Tenemos múltiples
opciones para implementar la validación de tokens a nivel del servidor de recursos. Describiré brevemente las **tres
opciones** y luego las detallaré una por una.

La primera opción permite que el **servidor de recursos llame directamente al servidor de autorizaciones** para
verificar un token emitido. La figura 14.2 muestra esta opción.

![figure-14-2](./assets/figure-14-2.png)

**La segunda opción utiliza una base de datos común** donde el servidor de autorización almacena tokens, y luego el
servidor de recursos puede acceder y validar los tokens (figura 14.3). Este enfoque también se denomina pizarra.

![figure-14-3](./assets/figure-14-3.png)

Finalmente, **la tercera opción utiliza firmas criptográficas** (figura 14.4). El **servidor de autorización firma el
token** cuando lo emite y el **servidor de recursos valida la firma.** Aquí es donde generalmente usamos
JSON Web Tokens (JWT). Discutimos este enfoque en el capítulo 15.

![figure-14-4](./assets/figure-14-4.png)

## [Pág. 341] Implementación de un servidor de recursos

Comenzamos con la implementación de nuestra primera aplicación de servidor de recursos, la última pieza del rompecabezas
de OAuth 2. La razón por la que tenemos un servidor de autorización que emite tokens es para permitir que los clientes
accedan a los recursos de un usuario. **El servidor de recursos administra y protege los recursos del usuario.** Por
esta razón, necesita saber cómo implementar un servidor de recursos. **Usamos la implementación predeterminada
proporcionada por Spring Boot**, que permite que **el servidor de recursos llame directamente al servidor de
autorización** para averiguar si un token es válido (figura 14.5).

![figure-14-5](./assets/figure-14-5.png)

**NOTA**
> Al igual que en el caso del servidor de autorizaciones, la implementación del servidor de recursos sufrió cambios en
> la comunidad Spring. Estos cambios nos afectan porque ahora, en la práctica, encuentras diferentes formas en las que
> los desarrolladores implementan el servidor de recursos. Proporciono ejemplos en los que puede configurar el servidor
> de recursos de dos maneras, de modo que cuando los encuentre en escenarios del mundo real, comprenderá y podrá usar
> ambos.

Agregamos las dependencias como en el siguiente fragmento de código:

````xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.0.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.magadiflo.book.security</groupId>
    <artifactId>spring-security-in-action-2020</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>spring-security-in-action-2020</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
        <spring-cloud.version>Hoxton.SR1</spring-cloud.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-oauth2</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
````

**NOTA**
Observar que estamos usando:

- Java: 1.8
- Spring Boot: 2.3.0.RELEASE
- Spring Cloud: Hoxton.SR1
- <dependencyManagement>...</dependencyManagement>
- Configurar IntelliJ IDEA a la versión Java 1.8

El propósito del servidor de recursos es administrar y proteger los recursos de un usuario. Entonces, para probar cómo
funciona, necesitamos un recurso al que queremos acceder. Creamos un punto final /hello para nuestras pruebas definiendo
el controlador habitual como se presenta en la siguiente lista.

````java

@RestController
public class HelloController {
    @GetMapping(path = "/hello")
    public String hello() {
        return "Hello";
    }
}
````

Lo otro que necesitamos es una clase de configuración en la que usamos la anotación **@EnableResourceServer** para
permitir que Spring Boot configure lo que se necesita **para que nuestra aplicación se convierta en un servidor de
recursos.** La siguiente lista presenta la clase de configuración.

````java

@EnableResourceServer
@Configuration
public class ResourceServerConfig {

}
````

Ahora tenemos un servidor de recursos. Pero no es útil si no puede acceder al punto final, como es nuestro caso porque
no configuramos ninguna forma en que el servidor de recursos pueda verificar los tokens. Sabe que las solicitudes de
recursos también deben proporcionar un token de acceso válido. Incluso si proporciona un token de acceso válido, una
solicitud aún no funcionará. Nuestro servidor de recursos no puede verificar que estos sean tokens válidos, que el
servidor de autorización los haya emitido. Esto se debe a que no implementamos ninguna de las opciones que tiene el
servidor de recursos para validar los tokens de acceso. Tomemos este enfoque y discutamos nuestras opciones en las
próximas dos secciones; el capítulo 15 presenta una opción adicional.

**NOTA**
> Como mencioné en una nota anterior, la implementación del servidor de recursos también cambió. La anotación
> @EnableResourceServer, que forma parte del proyecto Spring Security OAuth, se marcó recientemente como obsoleta. En la
> guía de migración de Spring
> Security (https://github.com/spring-projects/springsecurity/wiki/OAuth-2.0-Migration-Guide),
> el equipo de Spring Security nos invita a usar métodos de configuración directamente desde Spring Security.
> Actualmente, todavía encuentro el uso de proyectos Spring Security OAuth en la mayoría de las aplicaciones que veo.
> Por esta razón, considero importante que comprenda ambos enfoques que presentamos como ejemplos en este capítulo.

