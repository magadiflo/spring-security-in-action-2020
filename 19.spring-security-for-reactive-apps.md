# [Pág. 467] Capítulo 19 - Spring Security para aplicaciones reactivas

---

`Reactive` **es un paradigma de programación en el que aplicamos una forma diferente de pensar a la hora de desarrollar
nuestras aplicaciones.**

En algunos casos, un enfoque reactivo es excelente. En otros casos, puede que solo te complique la vida. Pero, al fin y
al cabo, **el enfoque reactivo existe porque aborda algunas limitaciones de la programación imperativa,** y así se
utiliza para evitar dichas limitaciones. **Una de estas limitaciones tiene que ver con la ejecución de grandes tareas**
que, de alguna manera, pueden fragmentarse. `Con un enfoque imperativo`, le das a la aplicación una tarea para ejecutar,
y la aplicación tiene la responsabilidad de resolverla. Si la tarea es grande, la aplicación puede tardar bastante
tiempo en resolverla. El cliente que asignó la tarea tiene que esperar a que ésta se resuelva por completo antes de
recibir una respuesta. `Con la programación reactiva`, puedes dividir la tarea para que la aplicación tenga la
oportunidad de abordar algunas de las subtareas de forma concurrente. De este modo, el cliente recibe los datos
procesados más rápidamente.

## [Pág. 468] ¿Qué son las aplicaciones reactivas?

Cuando implementamos aplicaciones reactivas, utilizamos **dos enfoques para implementar las funcionalidades**. La
siguiente lista detalla estos enfoques:

- `Con el enfoque imperativo, la aplicación procesa la mayor parte de los datos de una sola vez`. Por ejemplo,
  una aplicación cliente llama a un endpoint expuesto por el servidor y envía al backend todos los datos que deben
  procesarse. Digamos que implementas una funcionalidad en la que el usuario sube archivos. Si el usuario selecciona
  una serie de archivos, y **todos ellos son recibidos por la aplicación backend para ser procesados todos a la vez,
  estás trabajando con un enfoque imperativo.**
- `Con el enfoque reactivo, tu aplicación recibe y procesa los datos en fragmentos`. No todos los datos tienen que
  estar completamente disponibles desde el principio para ser procesados. **El backend recibe y procesa los datos a
  medida que los obtiene.** Digamos que el usuario selecciona algunos archivos, y el backend necesita cargarlos y
  procesarlos. El backend no espera a recibir todos los archivos a la vez antes de procesarlos. **El backend puede
  recibir los archivos uno a uno y procesar cada uno mientras espera a que lleguen más archivos.**

Para implementar aplicaciones reactivas, la especificación [**Reactive Streams**](http://www.reactive-streams.org/)
proporciona una forma estándar para el **procesamiento de flujos asíncronos**. Una de las implementaciones de esta
especificación es el [**Proyecto Reactor**](https://projectreactor.io/), que construye los cimientos del modelo de
programación reactiva de Spring. **Project Reactor proporciona una API funcional para componer Reactive Streams.**

Para tener una sensación más práctica, vamos a empezar con una implementación sencilla de una aplicación reactiva. En
mi caso crearé el proyecto
[spring-security-in-action-2020-cap-19-reactive-app](https://github.com/magadiflo/spring-security-in-action-2020-cap-19-reactive-app.git)
que corresponde al proyecto `ssia-ch19-ex1` del libro de Spring Security In Action 2020.

En el archivo `pom.xml`, necesitamos añadir la dependencia web reactiva `spring-boot-starter-webflux`. Esta dependencia
aloja el `Proyecto Reactor` y nos permite utilizar sus clases e interfaces relacionadas en nuestro proyecto:

````xml
<!--Spring Boot 3.1.4-->
<!--  Java 17-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

El siguiente fragmento de código muestra la definición de la clase HelloController. En la definición del endpoint,
observarás que he utilizado como **tipo de retorno un Mono**. Mono es uno de los conceptos esenciales que define una
implementación de Reactor. Cuando se trabaja con **Reactor**, a menudo se utiliza `Mono y Flux, que definen publishers
(fuentes de datos)`. En la especificación `Reactive Streams, un publisher se describe mediante la interfaz Publisher`,
**esta interfaz describe uno de los contratos esenciales utilizados con Reactive Streams.** El otro contrato es
el `Subscriber,` **este contrato describe el componente que consume los datos.**

````java

@RestController
@RequestMapping(path = "/api/v1/greetings")
public class HelloController {
    @GetMapping(path = "/hello")
    public Mono<String> hello() {
        return Mono.just("Hola Mundo!");
    }
}
````

**Cuando se diseña un endpoint que devuelve algo, el endpoint se convierte en un publisher**, por lo que tiene que
devolver una implementación de Publisher. `Si se utiliza Project Reactor, esto será un Mono o un Flux`.

- `Mono` es un publisher para un único valor.
- `Flux` es un publisher para múltiples valores.

La Figura 19.2 describe estos componentes y las relaciones entre ellos:

![in-a-reactive-stream](./assets/in-a-reactive-stream.png)

Ahora puede iniciar y probar la aplicación. Lo primero que se observa al mirar en el terminal de la aplicación es que
**Spring Boot ya no configura un servidor Tomcat. Spring Boot solía configurar un Tomcat para una aplicación web por
defecto. En su lugar, ahora Spring Boot autoconfigura Netty como servidor web reactivo por defecto** para un proyecto
Spring Boot.

Lo segundo que habrás observado al llamar **al endpoint es que no se comporta de forma diferente a un endpoint
desarrollado con un enfoque no reactivo.** Todavía puedes encontrar en el cuerpo de la respuesta HTTP el mensaje
Hola Mundo! que el endpoint devuelve en su stream Mono definido.

````bash
$ curl -v http://localhost:8080/api/v1/greetings/hello

>
< HTTP/1.1 200 OK
< Content-Type: text/plain;charset=UTF-8
<
Hola Mundo!
````

Pero, `¿por qué es diferente el enfoque reactivo en términos de Spring Security?` Entre bastidores, una implementación
reactiva utiliza múltiples hilos para resolver las tareas en el flujo. En otras palabras, cambia la filosofía de un hilo
por petición, que utilizamos para una aplicación web diseñada con un enfoque imperativo (figura 19.3). Y, a partir de
aquí, más diferencias:

- **La implementación de SecurityContext no funciona de la misma manera en aplicaciones reactivas.** Recuerda, **el
  SecurityContext está basado en un ThreadLocal**, y ahora tenemos más de un thread por petición. (Discutimos este
  componente en el capítulo 5.).
- **Debido al SecurityContext, cualquier configuración de autorización se ve ahora afectada.** Recuerda que **las
  reglas de autorización generalmente dependen de la instancia de Autenticación almacenada en el SecurityContext.** Así
  que ahora, las configuraciones de seguridad aplicadas en la capa del endpoint así como la funcionalidad de seguridad
  del método global se ven afectadas.
- El **UserDetailsService**, el componente responsable de recuperar los detalles del usuario, es una fuente de datos.
  Debido a esto, el servicio de detalles de usuario también **necesita soportar un enfoque reactivo.** (Aprendimos sobre
  este contrato en el capítulo 2).

![security-context-reactive-no-reactive](./assets/security-context-reactive-no-reactive.png)

Afortunadamente, Spring Security ofrece soporte para aplicaciones reactivas y cubre todos los casos en los que ya no
puedes utilizar las implementaciones para aplicaciones no reactivas.

**Continuaremos en este capítulo discutiendo la forma de implementar configuraciones de seguridad con Spring Security
para aplicaciones reactivas.** Comenzaremos en la sección 19.2 con la implementación de la gestión de usuarios y
continuaremos en la sección 19.3 con la aplicación de reglas de autorización de endpoints, donde descubriremos cómo
funciona el contexto de seguridad en las aplicaciones reactivas. Luego continuaremos nuestra discusión con la seguridad
de métodos reactivos, que reemplaza la seguridad de métodos globales de las aplicaciones imperativas.

## Gestión de Usuarios en Aplicaciones Reactivas

Continuamos la implementación de la aplicación
[spring-security-in-action-2020-cap-19-reactive-app](https://github.com/magadiflo/spring-security-in-action-2020-cap-19-reactive-app.git)
que corresponde al proyecto `ssia-ch19-ex1` del libro de Spring Security In Action 2020, que comenzamos en la sección
19.1 añadiendo un `ReactiveUserDetailsService` al contexto de la aplicación. **Queremos asegurarnos de que el endpoint**
`/api/v1/greetings/hello` **sólo puede ser llamado por un usuario autenticado**. Como su nombre indica, el contrato
`ReactiveUserDetailsService` define el servicio de detalles de usuario para una aplicación reactiva.

La definición del contrato es tan sencilla como la de `UserDetailsService`. El `ReactiveUserDetailsService` define un
método utilizado por Spring Security para recuperar un usuario por su nombre de usuario. **La diferencia es que el
método descrito por el** `ReactiveUserDetailsService` **devuelve directamente un** `Mono<UserDetails>` **y no el
UserDetails como ocurre para** `UserDetailsService`. El siguiente fragmento de código muestra la definición de la
interfaz `ReactiveUserDetailsService`:

````java
public interface ReactiveUserDetailsService {
    Mono<UserDetails> findByUsername(String username);
}
````

Como en el caso del `UserDetailsService`, puedes escribir una implementación personalizada
del `ReactiveUserDetailsService` para dar a Spring Security una forma de obtener los detalles del usuario. **Para
simplificar esta demostración, utilizaremos una implementación proporcionada por Spring Security**. La
implementación `MapReactiveUserDetailsService` almacena los detalles del usuario en memoria (igual que
el `InMemoryUserDetailsManager` que conoció en el capítulo 2). Cambiamos el fichero `pom.xml` del
proyecto `ssia-ch19-ex1` y añadimos la dependencia de `Spring Security`, como presenta el siguiente fragmento de código:

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <!-- Other dependencies-->
</dependencies>
````

A continuación creamos una clase de configuración y añadimos un `ReactiveUserDetailsService` y un `PasswordEncoder`
**al contexto de Spring Security**. He llamado a la clase de configuración `ProjectConfig`. Usando un
ReactiveUserDetailsService, definimos un usuario con su nombre de usuario `admin`, la contraseña `12345`, y un
`authority` que llamé `read`. Como puedes observar, **es similar a trabajar con un UserDetailsService.**
**La principal diferencia** en la implementación del `ReactiveUserDetailsService` es que **el método devuelve un objeto
Publisher reactivo que contiene los UserDetails en lugar de la propia instancia de UserDetails**. Spring Security se
encarga del resto de la integración.

````java

@Configuration
public class ProjectConfig {

    // Añade un ReactiveUserDetailsService al contexto Spring
    @Bean
    public ReactiveUserDetailsService reactiveUserDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("12345")
                .authorities("read")
                .build();

        // Crea un MapReactiveUserDetailsService para gestionar las instancias de UserDetails
        return new MapReactiveUserDetailsService(admin);
    }

    // Agrega un PasswordEncoder al contexto de Spring
    @Bean
    public PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }
}
````

Ahora, iniciamos y probamos la aplicación, podrías notar que puedes llamar al endpoint sólo cuando te autenticas usando
las credenciales apropiadas. En nuestro caso, **sólo podemos utilizar admin con su contraseña 12345**, ya que es el
único registro de usuario que hemos añadido.

El siguiente fragmento de código muestra el comportamiento de la aplicación cuando se llama al endpoint con
**credenciales válidas:**

````bash
$ curl -v -u admin:12345 http://localhost:8080/api/v1/greetings/hello

>
< HTTP/1.1 200 OK
< Content-Type: text/plain;charset=UTF-8
<
Hola Mundo!
````

Si llamamos al endpoint **sin enviarle credenciales (o con credenciales inválidas)** obtendremos el siguiente
resultado:

````bash
$ curl -v http://localhost:8080/api/v1/greetings/hello

>
< HTTP/1.1 401 Unauthorized
< WWW-Authenticate: Basic realm="Realm"
<
````

La Figura 19.4 explica la arquitectura que utilizamos en esta aplicación. Entre bastidores, un `AuthenticationWebFilter`
**intercepta la petición HTTP**. Este filtro **delega la responsabilidad de la autenticación a
un** `Authentication Manager`.
El `Authentication Manager` implementa el contrato `ReactiveAuthenticationManager`. **A diferencia de las aplicaciones
no reactivas, aquí no tenemos proveedores de autenticación**. El `ReactiveAuthenticationManager` **implementa
directamente la lógica de autenticación.**

![an-authentication-web-filter](./assets/an-authentication-web-filter.png)

**Si quieres crear tu propia lógica de autenticación personalizada, implementa la interfaz
ReactiveAuthenticationManager.** La arquitectura para aplicaciones reactivas no es muy diferente de la que ya hemos
discutido a lo largo de este libro para aplicaciones no reactivas. Como se muestra en la figura 19.4, **si la
autenticación involucra credenciales de usuario, entonces usamos un ReactiveUserDetailsService para obtener los detalles
del usuario y un PasswordEncoder para verificar la contraseña.**

Además, el framework todavía sabe inyectar una instancia de autenticación cuando la solicitas. Solicitas los detalles de
autenticación añadiendo `Mono<Authentication>` como parámetro al método en la clase controlador. El listado 19.3
presenta los cambios realizados en la clase controladora. De nuevo, **el cambio significativo es que se utilizan
publicadores reactivos**. Observa que necesitamos usar `Mono<Authentication>` en lugar del Authentication plano como
usábamos en las aplicaciones no reactivas:

````java

@RestController
@RequestMapping(path = "/api/v1/greetings")
public class HelloController {

    @GetMapping(path = "/hello")
    public Mono<String> hello(Mono<Authentication> authenticationMono) { // Solicita al framework que proporcione el objeto de autenticación
        return authenticationMono.map(authentication -> "Hola, " + authentication.getName());
    }

}
````

Re-ejecutando la aplicación y llamando al endpoint, se observa que el comportamiento es el presentado en el siguiente
fragmento de código:

````bash
$ curl -v -u admin:12345 http://localhost:8080/api/v1/greetings/hello

>
< HTTP/1.1 200 OK
< Content-Type: text/plain;charset=UTF-8
<
Hola, admin
````

Y ahora, probablemente tu pregunta sea, `¿de dónde viene el objeto Authentication?` **Al tratarse de una aplicación
reactiva, ya no podemos permitirnos usar un ThreadLocal** porque el framework está diseñado para gestionar el
SecurityContext. Pero **Spring Security nos ofrece una implementación diferente del context holder para aplicaciones
reactivas**, `ReactiveSecurityContextHolder`. **Usamos esto para trabajar con el SecurityContext en una aplicación
reactiva. Así que todavía tenemos el SecurityContext, pero ahora se gestiona de forma diferente.** La Figura 19.5
describe el final del proceso de autenticación una vez que el `ReactiveAuthenticationManager` autentica con éxito la
petición.

![reactiveauthenticationmanager-successfully](./assets/reactiveauthenticationmanager-successfully.png)

El listado 19.4 muestra cómo reescribir la clase del controlador si quieres **obtener los detalles de autenticación
directamente del contexto de seguridad**. Este enfoque es una alternativa a permitir que el framework lo inyecte a
través del parámetro del método.

````java

@RestController
@RequestMapping(path = "/api/v1/greetings")
public class HelloController {

    @GetMapping(path = "/hello")
    public Mono<String> hello() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .map(authentication -> "Hola, " + authentication.getName());
    }

}
````

Si vuelves a ejecutar la aplicación y pruebas de nuevo el endpoint, puedes observar que se comporta igual que en los
ejemplos anteriores de esta sección. Este es el comando

````bash
$ curl -v -u admin:12345 http://localhost:8080/api/v1/greetings/hello

>
< HTTP/1.1 200 OK
< Content-Type: text/plain;charset=UTF-8
<
Hola, admin
````

Ahora que sabes que **Spring Security ofrece una implementación para gestionar correctamente el SecurityContext en un
entorno reactivo**, sabes que así es como tu aplicación aplica las reglas de autorización. Y estos detalles que acabas
de aprender abren el camino a la configuración de las reglas de autorización, que discutiremos en la sección 19.3.

## Configuración de reglas de autorización en aplicaciones reactivas

En las secciones 19.1 y 19.2 hemos visto cómo Spring Security gestiona los usuarios y el SecurityContext en las
aplicaciones reactivas. Pero **una vez que la aplicación termina la autenticación y almacena los detalles de la petición
autenticada en el SecurityContext, es el momento de la autorización.**

Para enseñarte **cómo configurar reglas de autorización en apps reactivas**, primero discutiremos en la sección `19.3.1
la forma de hacer configuraciones en la capa endpoint`. Una vez que terminemos de discutir la configuración de
autorización en la capa de endpoint, aprenderás en la sección `19.3.2 cómo aplicarla en cualquier otra capa de tu
aplicación usando seguridad de métodos.`

