# [Pág. 467] Capítulo 19 - Spring Security para aplicaciones reactivas

---

`Reactive` **es un paradigma de programación en el que aplicamos una forma diferente de pensar a la hora de desarrollar
nuestras aplicaciones.**

En algunos casos, un enfoque reactivo es excelente. En otros casos, puede que solo te complique la vida. Pero, al fin y
al cabo, **el enfoque reactivo existe porque aborda algunas limitaciones de la programación imperativa,** y así se
utiliza para evitar dichas limitaciones. **Una de estas limitaciones tiene que ver con la ejecución de grandes tareas**
que, de alguna manera, pueden fragmentarse. `Con un enfoque imperativo`, le das a la aplicación una tarea para ejecutar,
y la aplicación tiene la responsabilidad de resolverla. Si la tarea es grande, la aplicación puede tardar bastante
tiempo en resolverla. El cliente que asignó la tarea tiene que esperar a que ésta se resuelva por completo antes de
recibir una respuesta. `Con la programación reactiva`, puedes dividir la tarea para que la aplicación tenga la
oportunidad de abordar algunas de las subtareas de forma concurrente. De este modo, el cliente recibe los datos
procesados más rápidamente.

## [Pág. 468] ¿Qué son las aplicaciones reactivas?

Cuando implementamos aplicaciones reactivas, utilizamos **dos enfoques para implementar las funcionalidades**. La
siguiente lista detalla estos enfoques:

- `Con el enfoque imperativo, la aplicación procesa la mayor parte de los datos de una sola vez`. Por ejemplo,
  una aplicación cliente llama a un endpoint expuesto por el servidor y envía al backend todos los datos que deben
  procesarse. Digamos que implementas una funcionalidad en la que el usuario sube archivos. Si el usuario selecciona
  una serie de archivos, y **todos ellos son recibidos por la aplicación backend para ser procesados todos a la vez,
  estás trabajando con un enfoque imperativo.**
- `Con el enfoque reactivo, tu aplicación recibe y procesa los datos en fragmentos`. No todos los datos tienen que
  estar completamente disponibles desde el principio para ser procesados. **El backend recibe y procesa los datos a
  medida que los obtiene.** Digamos que el usuario selecciona algunos archivos, y el backend necesita cargarlos y
  procesarlos. El backend no espera a recibir todos los archivos a la vez antes de procesarlos. **El backend puede
  recibir los archivos uno a uno y procesar cada uno mientras espera a que lleguen más archivos.**

Para implementar aplicaciones reactivas, la especificación [**Reactive Streams**](http://www.reactive-streams.org/)
proporciona una forma estándar para el **procesamiento de flujos asíncronos**. Una de las implementaciones de esta
especificación es el [**Proyecto Reactor**](https://projectreactor.io/), que construye los cimientos del modelo de
programación reactiva de Spring. **Project Reactor proporciona una API funcional para componer Reactive Streams.**

Para tener una sensación más práctica, vamos a empezar con una implementación sencilla de una aplicación reactiva. En
mi caso crearé el proyecto
[spring-security-in-action-2020-cap-19-reactive-app](https://github.com/magadiflo/spring-security-in-action-2020-cap-19-reactive-app.git)
que corresponde al proyecto `ssia-ch19-ex1` del libro de Spring Security In Action 2020.

En el archivo `pom.xml`, necesitamos añadir la dependencia web reactiva `spring-boot-starter-webflux`. Esta dependencia
aloja el `Proyecto Reactor` y nos permite utilizar sus clases e interfaces relacionadas en nuestro proyecto:

````xml
<!--Spring Boot 3.1.4-->
<!--  Java 17-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

El siguiente fragmento de código muestra la definición de la clase HelloController. En la definición del endpoint,
observarás que he utilizado como **tipo de retorno un Mono**. Mono es uno de los conceptos esenciales que define una
implementación de Reactor. Cuando se trabaja con **Reactor**, a menudo se utiliza `Mono y Flux, que definen publishers
(fuentes de datos)`. En la especificación `Reactive Streams, un publisher se describe mediante la interfaz Publisher`,
**esta interfaz describe uno de los contratos esenciales utilizados con Reactive Streams.** El otro contrato es
el `Subscriber,` **este contrato describe el componente que consume los datos.**

````java

@RestController
@RequestMapping(path = "/api/v1/greetings")
public class HelloController {
    @GetMapping(path = "/hello")
    public Mono<String> hello() {
        return Mono.just("Hola Mundo!");
    }
}
````

**Cuando se diseña un endpoint que devuelve algo, el endpoint se convierte en un publisher**, por lo que tiene que
devolver una implementación de Publisher. `Si se utiliza Project Reactor, esto será un Mono o un Flux`.

- `Mono` es un publisher para un único valor.
- `Flux` es un publisher para múltiples valores.

La Figura 19.2 describe estos componentes y las relaciones entre ellos:

![in-a-reactive-stream](./assets/in-a-reactive-stream.png)

Ahora puede iniciar y probar la aplicación. Lo primero que se observa al mirar en el terminal de la aplicación es que
**Spring Boot ya no configura un servidor Tomcat. Spring Boot solía configurar un Tomcat para una aplicación web por
defecto. En su lugar, ahora Spring Boot autoconfigura Netty como servidor web reactivo por defecto** para un proyecto
Spring Boot.

Lo segundo que habrás observado al llamar **al endpoint es que no se comporta de forma diferente a un endpoint
desarrollado con un enfoque no reactivo.** Todavía puedes encontrar en el cuerpo de la respuesta HTTP el mensaje
Hola Mundo! que el endpoint devuelve en su stream Mono definido.

````bash
curl -v http://localhost:8080/api/v1/greetings/hello

>
< HTTP/1.1 200 OK
< Content-Type: text/plain;charset=UTF-8
<
Hola Mundo!
````

Pero, `¿por qué es diferente el enfoque reactivo en términos de Spring Security?` Entre bastidores, una implementación
reactiva utiliza múltiples hilos para resolver las tareas en el flujo. En otras palabras, cambia la filosofía de un hilo
por petición, que utilizamos para una aplicación web diseñada con un enfoque imperativo (figura 19.3). Y, a partir de
aquí, más diferencias:

- **La implementación de SecurityContext no funciona de la misma manera en aplicaciones reactivas.** Recuerda, **el
  SecurityContext está basado en un ThreadLocal**, y ahora tenemos más de un thread por petición. (Discutimos este
  componente en el capítulo 5.).
- **Debido al SecurityContext, cualquier configuración de autorización se ve ahora afectada.** Recuerda que **las
  reglas de autorización generalmente dependen de la instancia de Autenticación almacenada en el SecurityContext.** Así
  que ahora, las configuraciones de seguridad aplicadas en la capa del endpoint así como la funcionalidad de seguridad
  del método global se ven afectadas.
- El **UserDetailsService**, el componente responsable de recuperar los detalles del usuario, es una fuente de datos.
  Debido a esto, el servicio de detalles de usuario también **necesita soportar un enfoque reactivo.** (Aprendimos sobre
  este contrato en el capítulo 2).

![security-context-reactive-no-reactive](./assets/security-context-reactive-no-reactive.png)

Afortunadamente, Spring Security ofrece soporte para aplicaciones reactivas y cubre todos los casos en los que ya no
puedes utilizar las implementaciones para aplicaciones no reactivas.

**Continuaremos en este capítulo discutiendo la forma de implementar configuraciones de seguridad con Spring Security
para aplicaciones reactivas.** Comenzaremos en la sección 19.2 con la implementación de la gestión de usuarios y
continuaremos en la sección 19.3 con la aplicación de reglas de autorización de endpoints, donde descubriremos cómo
funciona el contexto de seguridad en las aplicaciones reactivas. Luego continuaremos nuestra discusión con la seguridad
de métodos reactivos, que reemplaza la seguridad de métodos globales de las aplicaciones imperativas.