# OAuth 2 y OpenID Connect

---

- Este apartado `no es del libro Spring Security In Action 2020`, sino más bien un complemento que coloco como parte
  de la explicación de `¿qué es OAuth 2?` y además abarco el protocolo `OpenID Connect`. Para tratar estos temas
  utilizo como **referencia las documentaciones oficiales.**
- Hay un tutorial que hice del canal del `Luigi Code` donde utilizamos **Spring Boot 3 y Angular** para desarrollar
  estos temas. A continuación se muestran los repositorios de dichos proyectos:
    - [Servidor de Autorización](https://github.com/magadiflo/authorization-server.git)
    - [Servidor de Recursos](https://github.com/magadiflo/resource-server.git)
    - [Cliente OAuth 2](https://github.com/magadiflo/oauth2-client-angular.git)

---

## Fuentes consultadas

- [oauth.com](https://www.oauth.com/)
- [oauth.com/playground](https://www.oauth.com/playground/)
- [oauth.net](https://oauth.net/2/)

---

## [¿Qué es OAuth 2?](https://oauth.net/2/)

`OAuth 2.0 es el protocolo estándar del sector para la autorización`. OAuth 2.0 se centra en la simplicidad del
desarrollador cliente a la vez que `proporciona flujos de autorización específicos` para aplicaciones web, aplicaciones
de escritorio, teléfonos móviles y dispositivos de salón.

## [OAuth Access Tokens](https://oauth.net/2/access-tokens/)

Un `token de acceso OAuth` es una cadena que el `cliente OAuth` utiliza para
`realizar peticiones al servidor de recursos`.

Los tokens de acceso no tienen que estar en ningún formato en particular, y en la práctica, varios servidores OAuth han
elegido muchos formatos diferentes para sus tokens de acceso.

Los tokens de acceso pueden ser  `"bearer tokens"` o `"sender-constrained"`.

Hay una serie de propiedades de los tokens de acceso que son fundamentales para el modelo de seguridad de OAuth:

- Los tokens de acceso no deben ser leídos o interpretados por el cliente OAuth. El cliente OAuth no es el destinatario
  del token.
- Los tokens de acceso no transmiten la identidad del usuario ni ninguna otra información sobre el usuario al cliente
  OAuth.
- Los tokens de acceso sólo deben utilizarse para realizar solicitudes al servidor de recursos. Además, los tokens de
  identificación `(ID Tokens)` no deben utilizarse para realizar solicitudes al servidor de recursos.

## [OAuth Refresh Tokens](https://oauth.net/2/refresh-tokens/)

Un `OAuth Refresh Token` es una cadena que el `cliente OAuth` puede utilizar para obtener un nuevo `access token` sin
la interacción del usuario.

Un token de actualización no debe permitir al cliente obtener ningún acceso más allá del alcance de la concesión
original. El token de actualización existe para permitir a los servidores de autorización utilizar tiempos de vida
cortos para los tokens de acceso sin necesidad de involucrar al usuario cuando el token expira.

## [OAuth Scopes](https://oauth.net/2/scope/)

`El ámbito (scope) es un mecanismo de OAuth 2.0 para limitar el acceso de una aplicación a la cuenta de un usuario`. Una
aplicación puede solicitar uno o más ámbitos, esta información se presenta al usuario en
la `pantalla de consentimiento`, y el access token emitido a la aplicación se limitará a los ámbitos concedidos.

OAuth no define ningún valor concreto para los ámbitos, ya que depende en gran medida de la arquitectura y las
necesidades internas del servicio.

**Ejemplos de ámbitos en servicios populares:**

- `GitHub`:  read:user, user:email, user:follow, etc.
- `Google`: openid, https://www.googleapis.com/auth/userinfo.profile, https://www.googleapis.com/auth/userinfo.email,
  etc.
- `slack`: admin.users:write, emoji:read, files:read, files:write:user, etc.

## [OAuth Grant Types](https://oauth.net/2/grant-types/)

El marco OAuth especifica varios tipos de concesión para diferentes casos de uso, así como un marco para crear nuevos
tipos de concesión.

A continuación se enumeran los tipos de concesión de OAuth más comunes:

- Authorization Code
- PKCE
- Client Credentials
- Device Code
- Refresh Token

A continuación se enumeran los tipos de concesión que en la actualidad ya son `legacy`:

- Implicit Flow
- Password Grant

---

## [OAuth 2.0 Authorization Code Grant](https://oauth.net/2/grant-types/authorization-code/)

El tipo de concesión de código de autorización es **utilizado por clientes confidenciales y públicos** para intercambiar
un `código de autorización` por un `access token`.

Después de que el usuario vuelva al cliente a través de la URL de redirección, la aplicación obtendrá el código de
autorización de la URL y lo utilizará para solicitar un token de acceso.

`Se recomienda que todos los clientes utilicen también la extensión PKCE con este flujo para proporcionar una mayor
seguridad.`

Para comprender mejor la **Concesión de Código de Autorización** realizaré un ejemplo del paso a paso utilizando
como referencia los ejemplos de [OAuth 2.0 Playground](https://www.oauth.com/playground/index.html) y
[okta Developer](https://developer.okta.com/blog/2018/04/10/oauth-authorization-code-grant-type):

### Registrar un cliente en el Servidor de Autorización

Antes de que puedas comenzar el flujo, necesitarás **registrar un cliente (aplicación) y crear un usuario**. El registro
te dará un `ID de cliente` y un `secreto` que tu aplicación utilizará durante el flujo OAuth.

Para este ejemplo, como estamos trabajando sobre una simulación proporcionada por la página de
[OAuth 2.0 Playground](https://www.oauth.com/playground/index.html), éste nos proporciona unos credenciales de cliente
y de usuarios ficticios:

![client-registration-oauth2](./assets/client-registration-oauth2.png)

### 1° Paso: Construir la URL de autorización

Antes de que comience la autorización, primero genera una `cadena aleatoria` **para utilizarla en el parámetro state.**
El cliente tendrá que almacenarla para utilizarla en el siguiente paso.

Para esta demostración, hemos generado un parámetro de estado aleatorio y lo hemos guardado en una cookie. El valor
de nuestro parámetro `state` será:

````
LixvW7NZdpNuvmWr
````

**Para comenzar el flujo de autorización**, la aplicación construye una URL como la siguiente y abre un navegador a esa
URL:

````
https://authorization-server.com/authorize?
  response_type=code
  &client_id=wQDtb30PhkMDGEtMm6n3Gf8n
  &redirect_uri=https://www.oauth.com/playground/authorization-code.html
  &scope=photo+offline_access
  &state=LixvW7NZdpNuvmWr
````

**DONDE:**

- `response_type=code`, indica al servidor de autorización que la aplicación está iniciando el flujo de código de
  autorización.
- `client_id`, el identificador público de la aplicación, obtenido cuando el desarrollador registró la aplicación por
  primera vez.
- `redirect_uri`, indica al servidor de autorización a dónde debe enviar al usuario después de aprobar la solicitud.
- `scope`, una o más cadenas separadas por espacios que indican qué permisos solicita la aplicación.
- `state`, la aplicación genera una **cadena aleatoria** y la incluye en la solicitud. A continuación, debe comprobar
  que se devuelve el mismo valor después de que el usuario autorice la aplicación. Esto se utiliza para prevenir ataques
  CSRF.

Cuando el usuario visite esta URL, se nos pedirá que nos autentiquemos, lo haremos con las credenciales de usuario que
nos generó la simulación. A continuación el servidor de autorización le preguntará si desea autorizar la solicitud de
esta aplicación:

![authorization-code-open-id-connect](./assets/authorization-code-open-id-connect.png)

Si el usuario aprueba la solicitud `(clic en Approve)`, el servidor de autorización redirigirá el navegador de vuelta a
la `redirect_uri` especificada por la aplicación, `añadiendo un código` y un `estado` a la cadena de consulta.

### 2° Paso: Verificar el parámetro de estado

Entonces, como decíamos el usuario ha sido redirigido de nuevo al cliente, y observará algunos parámetros de consulta
adicionales en la URL `state` y `code`:

````
?state=LixvW7NZdpNuvmWr&code=50bcijlVSwce6viKmkduelVqPJX-Yei_6UB_XaroUVj0WaP7
````

**DONDE:**

- El `code` es el código de autorización generado por el servidor de autorización. Este código dura relativamente poco,
  normalmente entre 1 y 10 minutos dependiendo del servicio OAuth. `[Además, el código es de 1 solo uso].`
- El valor del `state` será el mismo que la aplicación estableció inicialmente en la solicitud. Se espera que la
  aplicación compruebe que el estado en la redirección coincide con el estado que estableció originalmente.
  **Esto protege contra CSRF y otros ataques relacionados.**

Entonces, en este segundo paso, lo que debemos hacer es **verificar que el parámetro de estado coincide con el valor
almacenado en la sesión de este usuario** para protegerse contra ataques CSRF.

Dependiendo de cómo haya almacenado el parámetro de estado (en una cookie, sesión o de alguna otra forma), verifique que
coincide con el estado que incluyó originalmente en el paso 1. Anteriormente, habíamos almacenado el estado en una
cookie para esta demostración.

**¿Coincide el estado almacenado por el cliente** `LixvW7NZdpNuvmWr` **con el estado en la redirección**
`LixvW7NZdpNuvmWr`**?** Como la respuesta **es afirmativa, continuamos con el tercer paso de la concesión.**

Si la comparación es incorrecta, es probable que sea víctima de un ataque CSRF, podemos lanzar un mensaje de
[error HTTP 401 Unauthorized](https://learn.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow?tabs=HTTPS1)
e indicarle que debemos comenzar de nuevo.

### 3° Paso: Intercambiar el Código de Autorización por un Access Token

Estamos a punto de terminar el flujo. Ahora que `la aplicación tiene el código de autorización, puede usarlo para
obtener un token de acceso`.

La aplicación realiza una `solicitud POST` al endpoint de token del servicio con los siguientes parámetros:

````
[POST] https://authorization-server.com/token

grant_type=authorization_code
&client_id=wQDtb30PhkMDGEtMm6n3Gf8n
&client_secret=EKZbOXvcS7xNhKIhHEVK-SHs66kkXhlsQ7iHwEhsf2IVi1Pq
&redirect_uri=https://www.oauth.com/playground/authorization-code.html
&code=50bcijlVSwce6viKmkduelVqPJX-Yei_6UB_XaroUVj0WaP7
````

**DONDE:**

- `grant_type=authorization_code`, esto indica al endpoint del token que la aplicación está utilizando el tipo de
  concesión Authorization Code.
- `client_id`, ID de cliente de la aplicación.
- `client_secret`, el secreto de cliente de la aplicación. Esto garantiza que la solicitud para obtener el token de
  acceso se realice únicamente desde la aplicación, y no desde un posible atacante que pueda haber interceptado el
  código de autorización.
- `redirect_uri`, el mismo URI de redirección que se utilizó al solicitar el código. Algunas API no requieren este
  parámetro, por lo que deberá consultar la documentación de la API concreta a la que esté accediendo.
- `code`, la aplicación incluye el código de autorización que se le dio en la redirección.

> Tenga en cuenta que las credenciales del cliente se incluyen en el cuerpo POST en este ejemplo. Otros servidores de
> autorización pueden requerir que las credenciales se envíen como una cabecera HTTP de autenticación básica.

El endpoint del token verificará todos los parámetros de la solicitud, asegurándose de que el código no ha caducado y
de que el ID de cliente y el secreto coinciden. Si todo es correcto, generará un `access_token` y un `refresh_token`
y lo devolverá en la respuesta:

````
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
  "token_type": "Bearer",
  "expires_in": 86400,
  "access_token": "58l8G2DOJPg3fGt-J4Ns3bBquxme99VHLX9pVJZzsrnbhibG26y5mxMq6wcuJQTT_vMUTo6L",
  "scope": "photo offline_access",
  "refresh_token": "ZR2QopSMCZp63F6pXY7xw0sA"
}
````

**El flujo del código de autorización está completo**. Ahora tu aplicación tiene un `access token`, y puede usarlo para
hacer peticiones a la API en nombre del usuario.

**NOTA**

> Si estás utilizando el flujo de Código de Autorización en una aplicación móvil, o cualquier otro tipo de aplicación
> que no pueda almacenar un secreto de cliente, entonces también deberías utilizar la `extensión PKCE`, que proporciona
> protecciones contra otros ataques en los que el código de autorización puede ser interceptado.

## [PKCE (Proof Key for Code Exchange)](https://oauth.net/2/pkce/)

`Proof Key for Code Exchange o Clave de prueba para el intercambio de código (abreviado PKCE, pronunciado "pixie")`
es una `extensión` del flujo de `código de autorización` para **prevenir ataques CSRF y de inyección de código
de autorización**.

La técnica consiste en que **el cliente cree primero un secreto en cada solicitud de autorización, y luego vuelva a
utilizar ese secreto cuando intercambie el código de autorización por un token de acceso**. De esta forma, si
el código es interceptado, no será útil, ya que la solicitud del token se basa en el secreto inicial.

PKCE no es una forma de autenticación de cliente, y `PKCE no es un reemplazo para un secreto de cliente` u otra
autenticación de cliente. `PKCE se recomienda incluso si un cliente está utilizando un secreto de cliente` u otra
forma de autenticación de cliente como private_key_jwt.

**Nota:** Dado que PKCE no sustituye a la autenticación de clientes, no permite tratar a un cliente público como cliente
confidencial.

PKCE se diseñó originalmente para proteger el flujo del `código de autorización` en aplicaciones móviles, y **más
tarde se recomendó su uso también en aplicaciones de una sola página**. En años posteriores, se reconoció que su
capacidad para evitar la inyección de código de autorización lo hace útil para todo tipo de cliente OAuth, incluso
aplicaciones que se ejecutan en un servidor web que utilizan un secreto de cliente. **Debido a su historia en el uso de
aplicaciones móviles y aplicaciones de una sola página, a veces se piensa erróneamente que PKCE es una alternativa a un
secreto de cliente**. Sin embargo,
`PKCE no sustituye a un secreto de cliente, y se recomienda PKCE incluso si un cliente utiliza un secreto de cliente`,
ya que las aplicaciones con un secreto de cliente siguen siendo susceptibles de sufrir ataques de inyección de código de
autorización.

La especificación completa está disponible como `RFC7636`. A continuación presentamos un resumen del protocolo:

### [1° Paso: Solicitar Authorization](https://www.oauth.com/oauth2-servers/pkce/authorization-request/)

Cuando la app nativa inicia la solicitud de autorización, en lugar de lanzar inmediatamente un navegador, **el cliente
crea primero** lo que se conoce como `"code verifier"`. Se trata de una cadena criptográficamente aleatoria que
utiliza los caracteres A-Z, a-z, 0-9 y los caracteres de puntuación -._~ (guión, punto, guión bajo y tilde), con una
longitud de entre 43 y 128 caracteres.

Una vez que la aplicación ha generado el `code verifier`, lo utiliza para derivar el `code challenge`.
Para los dispositivos que pueden realizar un `hash SHA256`, el `code challenge` es una cadena en `Base64-URL-encoded`
del hash `SHA256` del `code verifier`. Los clientes que no pueden realizar un hash SHA256 pueden utilizar como
`challenge` la cadena sin formato del `code verifier`, aunque esto ofrece menos ventajas de seguridad, por lo que sólo
debe utilizarse si es absolutamente necesario.

`Base64-URL-encoded` es una variación menor del típico método de codificación Base64. Comienza con el mismo método de
`Base64-encoding` disponible en la mayoría de los lenguajes de programación, pero en su lugar utiliza caracteres
`URL-safe` (url seguro). Puedes implementar un método `Base64-URL-encoding` tomando un `Base64-encoded` y
realizando las siguientes modificaciones en la cadena:  Toma la cadena `Base64-encoded` y `cambia + por -`, y
`/ por _`, luego `elimina el signo igual (=) del final`.

````javascript
function base64_urlencode(str) {
  return btoa(String.fromCharCode.apply(null, 
    new Uint8Array(str)))
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=+$/, '');
}
````

Ahora que el cliente tiene un `code challenge` (desafío de código), incluye eso y un parámetro que indica qué método se
utilizó para generar el desafío `(plain o S256)` junto con los parámetros estándar de la solicitud de autorización.
Esto significa que **una solicitud de autorización completa incluirá los siguientes parámetros**:

- `response_type=code`, le dice al servidor de autorización que el cliente espera un **código de autorización**. El
  cliente necesita el código para obtener un access token.
- `client_id`, el ID de cliente que recibió cuando creó la aplicación por primera vez.
- `redirect_uri`, indica la URL a la que debe volver el usuario una vez completada la autorización, como
  **org.example.app://redirect**.
- `state=1234zyx`, una cadena aleatoria generada por tu aplicación, que verificarás más tarde.
- `code_challenge=XXXXXXXXX`, el desafío de código generado como se ha descrito anteriormente.
- `code_challenge_method=S256`, ya sea plain o S256, dependiendo de si el reto es la cadena de verificación plain o el
  hash SHA256 de la cadena.

El servidor de autorización debe reconocer el parámetro `code_challenge` en la solicitud, y **asociarlo con el
código de autorización que genera**. Puede almacenarlo en la base de datos junto con el código de autorización o,
si utiliza códigos de autorización autocodificados, puede incluirlo en el propio código.
[(Véase La respuesta de autorización para más detalles)](https://www.oauth.com/oauth2-servers/authorization/the-authorization-response/)
El servidor devuelve el **código de autorización** de forma normal y **no incluye el challenge** en los datos devueltos.

**Respuesta de error**

**El servidor de autorización puede requerir que los clientes públicos utilicen la extensión PKCE**. Esta es realmente
la única manera de permitir que **las aplicaciones nativas tengan un flujo de autorización seguro sin utilizar el
secreto del cliente**, especialmente sin la seguridad de redirección URI que está disponible con los clientes basados en
web. Dado que el servidor de autorización debe saber que un ID de cliente específico corresponde a un cliente público,
puede denegar las solicitudes de autorización de clientes públicos que no contengan un `code challenge`.

Si el servidor de autorización requiere que los clientes públicos utilicen PKCE, y a la solicitud de autorización le
falta el `code challenge`, entonces el servidor debe devolver la respuesta de error con `error=invalid_request` y
`error_description` o `error_uri` deben explicar la naturaleza del error.

### [2° Paso: Intercambio Authorization Code](https://www.oauth.com/oauth2-servers/pkce/authorization-code-exchange/)

A continuación, la aplicación intercambiará el código de autorización por un token de acceso. Además de los parámetros
definidos en la solicitud de código de autorización, el cliente también enviará el parámetro `code_verifier`.

Una solicitud de token de acceso completa incluirá los siguientes parámetros:

- `grant_type=authorization_code`, indica el tipo de concesión de esta solicitud de token.
- `code`, el cliente enviará el código de autorización que obtuvo en la redirección.
- `redirect_uri`, la URL de redirección que se utilizó en la solicitud de autorización inicial.
- `client_id`, el ID de la aplicación cliente registrado.
- `client_secret (opcional)`, el secreto de la aplicación cliente registrada si se emitió un secreto.
- `code_verifier`, el verificador de código para la solicitud PKCE, que la aplicación generó originalmente antes de la
  solicitud de autorización.

Dado que el `code_challenge` y el `code_challenge_method` se asociaron inicialmente al código de autorización, el
servidor ya debería saber qué método utilizar para verificar el `code_verifier`.

Si el método es `plain`, el servidor de autorización sólo tiene que comprobar que el `code_verifier` proporcionado
coincide con la cadena esperada del `code_challenge`. Si el método es S256, entonces el servidor de autorización debe
tomar el `code_verifier` proporcionado y transformarlo utilizando el mismo método hash, y luego compararlo con la
cadena `code_challenge` almacenada.

Si el verificador coincide con el valor esperado, entonces el servidor puede continuar normalmente, emitiendo un
`acess_token` y respondiendo apropiadamente. Si hay un problema, entonces el servidor responde con un
error `invalid_grant`.

La extensión PKCE no añade ninguna respuesta nueva, por lo que los clientes siempre pueden utilizar la extensión PKCE
aunque un servidor de autorización no la admita.

### Generadores de código PKCE en línea

- [PKCE Code Generator](https://developer.pingidentity.com/en/tools/pkce-code-generator.html)
  (developer.pingidentity.com)
- [OAuth 2.0 `<debugger/>` Test OAuth 2.0 requests and debug responses](https://oauthdebugger.com/debug)
  (oauthdebugger.com)

En la imagen siguiente muestro la página de `oauthdebugger.com`, página que utilicé en el tutorial de `Luigi Code` cuyas
referencias coloqué al inicio de este README.

![pkce-code-generator](./assets/pkce-code-generator.png)

Centremos nuestra atención en los siguientes valores:

- `code_verifier`: RLVleJE1jVStvGEHgTseCob5OXrSCqLtmZJi7fj5kZ6
- `code_challenge`: SGnpsFzi5SDzVXmIUHIaLa-hA6uNoIcG_6G_NwH4kZ0
- `code_challenge_method`: S256

Cuando realizamos el `1° Paso: Solicitar Authorization` enviamos el `code_challenge` junto con el
`code_challenge_method`, estos valores se almacenan en el Servidor de Autorización y se asocian al Código de
Autorización retornado.

Cuando realizamos el `2° Paso: Intercambio Authorization Code` enviamos el `code_verifier` (obviamente otros valores
más, pero ahora estamos centrándonos en la extensión PKCE) y será el servidor de autorización quien a partir de ese
`code_verifier` y el método `code_challenge_method` almacenado inicialmente, genere un nuevo `code_challenge` y al final
compare el nuevo `code_challenge` con el `code_challenge` almacenado en el primer paso del flujo.

A continuación veamos la siguiente imagen donde vemos que **a partir de un code_verifier podemos generar
un code_challenge, pero no al revés**, para eso nos apoyaremos de una web en línea:

![sha-256](./assets/sha-256.png)

Entonces, que pasa si alguien obtiene el `authorization code` otorgado en el primer paso del flujo, pues no podrá
solicitar un `access token`, ya que necesita el `code_verifier` y quien tiene el `code_verifier` es el cliente original
quien inició el proceso de autorización.

Ahora, en la imagen se muestra el código generado en base64 quizá algo distinto (con el =, +, /), pero como se
mencionó en el paso `1° Paso: Solicitar Authorization` el Base64 encoded generado debe ser tratado para convertirlo
en un `Base64-URL-encoded`.

### [¿Cuál es la diferencia entre clientes confidenciales y públicos?](https://www.youtube.com/watch?v=5cQNwifDq1U)

En el protocolo OAuth 2 tenemos estas equivalencias:

- **Client** = Application
- **Resource Owner**  = User

Ahora, **¿qué significa confidencial clients y public clients?**, esto hace referencia si las aplicaciones tienen o no
la capacidad de mantener un `secret`. Veamos más detalles:

- `Confidential clients`: **son aplicaciones que pueden guardar un secret**. Por ejemplo: aplicaciones que
  se ejecutan en el lado del servidor `(backend)` o cualquier lugar donde se puedan definir variables y entradas de
  configuración en el entorno del lado del servidor, los secrets permanecerán allí y no serán visibles para los usuarios
  de la aplicación (client). En definitiva, son **clientes confidenciales** aquellas aplicaciones que son construidas
  usando un lenguaje del lado del servidor, tales como: `Java, PHP, .Net, etc`.
- `Public clients`: **son aplicaciones que NO PUEDEN guardar un secret**. Por ejemplo: una aplicación de JavaScript como
  un SPA usando Angular, pues todo el código fuente de la aplicación se descarga en el navegador. Otro ejemplo son
  las aplicaciones móviles, dispositivos integrados, internet de las cosas o incluso Apple TV.

Por lo tanto, ahora tenemos un problema, pues **los public clients no pueden usar el secreto en el flujo del tipo de
concesión de Código de Autorización** `¿Qué hacer?`.

Lo que haremos será que cuando la aplicación esté lista para iniciar un flujo OAuth, en realidad genera un secreto sobre
la marcha para ese intercambio en particular. Usará ese secreto cuando inicia el flujo de OAuth y luego nuevamente el
servidor OAuth requerirá ese secreto cuando se envíe el código de autorización intercambiando por el access token,
`esta técnica se llama PKCE`.

Los clientes públicos usan PKCE en lugar de un secreto de cliente.

## [OAuth 2.0 Client Credentials Grant](https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/)

La concesión de credenciales de cliente se usa cuando las aplicaciones solicitan un token de acceso para acceder a sus
propios recursos, no en nombre de un usuario.

## [OAuth 2.0 Refresh Token](https://www.oauth.com/oauth2-servers/access-tokens/refreshing-access-tokens/)

El tipo de concesión Refresh Token es utilizado por los clientes para intercambiar un refresh token por un token de
acceso cuando el token de acceso ha caducado.

Esto permite a los clientes seguir disponiendo de un token de acceso válido sin necesidad de interactuar con el usuario.

---

## [(LEGACY) OAuth 2.0 Implicit Grant](https://oauth.net/2/grant-types/implicit/)

El flujo implícito **era un flujo OAuth simplificado recomendado anteriormente para aplicaciones nativas y aplicaciones
JavaScript** en las que **el token de acceso se devolvía inmediatamente sin un paso adicional de intercambio de código
de autorización.**

**No se recomienda utilizar el flujo implícito** (y algunos servidores prohíben este flujo por completo) debido a los
riesgos inherentes de devolver tokens de acceso en una redirección HTTP sin ninguna confirmación de que ha sido recibido
por el cliente.

`Los clientes públicos, como las aplicaciones nativas y las aplicaciones JavaScript, deben utilizar ahora el flujo de
código de autorización con la extensión PKCE.`

El documento OAuth 2.0 Security Best Current Practice recomienda no utilizar el flujo Implicit en su totalidad, y OAuth
2.0 for Browser-Based Apps describe la técnica de utilizar el flujo de código de autorización con PKCE en su lugar.

## [(LEGACY) OAuth 2.0 Password Grant](https://oauth.net/2/grant-types/password/)

El tipo de concesión Contraseña es una forma heredada de intercambiar las credenciales de un usuario por un token de
acceso. Dado que la aplicación cliente tiene que recopilar la contraseña del usuario y enviarla al servidor de
autorización, no se recomienda seguir utilizando esta concesión.

Este flujo no proporciona ningún mecanismo para cosas como la autenticación multifactor o cuentas delegadas, por lo que
es bastante limitante en la práctica.

La última práctica recomendada de seguridad de **OAuth 2.0 prohíbe por completo la concesión de contraseña**, y
**la concesión no está definida en OAuth 2.1**.

---

## [¿Qué es OpenID Connect?](https://auth0.com/es/intro-to-iam/what-is-openid-connect-oidc)

`OpenID Connect u OIDC` es un protocolo de identidad que utiliza los mecanismos de autorización y autenticación de
OAuth 2.0.

`OpenID Connect es un protocolo de autenticación interoperable basado en el marco de especificaciones OAuth 2.0`.
Simplifica la forma de verificar la identidad de los usuarios basándose en la autenticación realizada por
un servidor de autorización y de obtener información sobre el perfil del usuario de forma interoperable y similar a
REST. ([Fuente: OpenID](https://openid.net/developers/how-connect-works/))

OIDC fue desarrollado por la Fundación OpenID, que incluye empresas como Google y Microsoft. Mientras que OAuth 2.0 es
un protocolo de autorización, `OIDC es un protocolo de autenticación de identidad y puede utilizarse para verificar la
identidad de un usuario ante un servicio de cliente`, también llamado **Parte de confianza**. Además, las declaraciones
de los usuarios, por ejemplo, el nombre, la dirección de correo electrónico, etc., también pueden ser compartidas a
petición.

Una amplia variedad de clientes pueden utilizar OpenID Connect (OIDC) para identificar a los usuarios, desde
aplicaciones de una sola página (SPA) hasta aplicaciones nativas y móviles. También puede utilizarse para el inicio de
sesión único (SSO) entre aplicaciones. OIDC utiliza JSON Web Tokens (JWT), flujos HTTP y evita compartir las
credenciales del usuario con los servicios.

## ¿Cómo encaja OpenID Connect con OAuth 2?

OIDC utiliza OAuth 2.0 como protocolo subyacente. Las principales extensiones son un valor del ámbito especial
`("openid")`, el uso de un token adicional (el `ID Token`, que encapsula las reclamaciones de identidad en
formato JSON), y el `énfasis en la autenticación en lugar de la autorización`. Además, en OIDC, el término `"flujo"`
se utiliza en lugar de `"concesión"` de OAuth2

## Principios y definiciones de OpenID Connect

- El `proveedor de OIDC` **(generalmente llamado proveedor de OpenID o proveedor de identidad)** `realiza la
  autenticación del usuario`, el consentimiento del usuario y la emisión de tokens.
- `Parte de confianza (RP)`, puede ser, por ejemplo, **una aplicación web**, pero también una aplicación JavaScript o
  una aplicación móvil.

`Al estar construido sobre OAuth 2.0, OpenID Connect utiliza tokens` para proporcionar una capa de identidad simple
integrada con el marco de autorización subyacente. Esta integración implica el uso de los siguientes tipos de token:

- `ID Token`, específicamente para OIDC, **el uso principal de este token en formato JWT es proporcionar información
  sobre el resultado de la operación de autenticación**. Mediante previa solicitud, puede proporcionar los datos de
  identidad que describen un perfil de usuario. Los datos sobre el resultado de la autenticación y la información del
  perfil del usuario se denominan reclamaciones `claims`. Las reivindicaciones del perfil del usuario pueden ser
  cualquier dato que sea pertinente para la Parte de confianza a efectos de identificación, como un ID persistente, una
  dirección de correo electrónico, un nombre, etc.
- `Access Token`, definido en OAuth2, este token (opcional) de corta duración proporciona acceso a recursos
  específicos del usuario, tal y como se define en los valores del ámbito en la solicitud al servidor de autorización.
- `Refresh Token`, según las especificaciones de OAuth2, este token suele ser de larga duración y puede usarse
  para obtener nuevos tokens de acceso.

---

## [ID Token and Access Token: ¿Cuál es la diferencia?](https://auth0.com/blog/id-token-access-token-what-is-the-difference/)

- [ID Token and Access Token: What Is the Difference?](https://auth0.com/blog/id-token-access-token-what-is-the-difference/)
- [ID Tokens vs Access Tokens](https://oauth.net/id-tokens-vs-access-tokens/)

### ¿Qué es un ID Token?

`Un token de identificación es un artefacto que prueba que el usuario ha sido autenticado.` Fue introducido por
OpenID Connect (OIDC), un `estándar abierto para la autenticación` utilizado por muchos proveedores de identidad
como Google, Facebook, y, por supuesto, Auth0. Echemos un vistazo rápido al problema que OIDC quiere resolver.

Considere el siguiente diagrama:

![get-id-token](./assets/get-id-token.png)

Aquí, **un usuario** con su navegador se **autentica contra un proveedor OpenID** y obtiene acceso a una aplicación
web. **El resultado de ese proceso de autenticación basado en OpenID Connect es el ID token**, que se pasa
a la aplicación como prueba de que el usuario ha sido autenticado.

Esto proporciona una idea muy básica de lo que es un token de identificación: `una prueba de la autenticación del
usuario`. Veamos otros detalles.

Un token de identificación se codifica como un JSON Web Token (JWT), un formato estándar que permite a tu aplicación
inspeccionar fácilmente su contenido, y asegurarse de que proviene del emisor (issuer) esperado y que nadie más
lo ha cambiado.

En pocas palabras, un ejemplo de `ID token` es el siguiente:

````
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwOi8vbXktZG9tYWluLmF1dGgwLmNvbSIsInN1YiI6ImF1dGgwfDEyMzQ1NiIsImF1ZCI6IjEyMzRhYmNkZWYiLCJleHAiOjEzMTEyODE5NzAsImlhdCI6MTMxMTI4MDk3MCwibmFtZSI6IkphbmUgRG9lIiwiZ2l2ZW5fbmFtZSI6IkphbmUiLCJmYW1pbHlfbmFtZSI6IkRvZSJ9.bql-jxlG9B_bielkqOnjTY9Di9FillFb6IMQINXoYsw
````

Por supuesto, esto no es legible para el ojo humano, así que tienes que decodificarlo para ver qué contenido tiene el
JWT. Por cierto, **el ID token no está encriptado, sino sólo codificado en Base 64**. Puedes utilizar una de las muchas
bibliotecas disponibles para descodificarlo, o puedes examinarlo tú mismo con el depurador jwt.io.

Sin profundizar en los detalles, la información relevante que lleva el ID token de arriba tiene el siguiente aspecto:

````json
{
  "iss": "http://my-domain.auth0.com",
  "sub": "auth0|123456",
  "aud": "1234abcdef",
  "exp": 1311281970,
  "iat": 1311280970,
  "name": "Jane Doe",
  "given_name": "Jane",
  "family_name": "Doe"
}
````

**Estas propiedades JSON se denominan claims**, y son declaraciones sobre el usuario y el propio token. **Las
declaraciones sobre el usuario definen la identidad del usuario.**

> En realidad, las especificaciones de OpenID Connect no exigen que el token de identificación tenga declaraciones del
> usuario. En su estructura mínima, no tiene datos sobre el usuario; solo información sobre la operación de
> autenticación.

Un `claim` importante es el claim de audiencia `(aud)`. Este claim define la audiencia del token, es decir, **la
aplicación web que debe ser el destinatario final del token.** En el caso del ID token, su valor es el ID de cliente
de la aplicación que debe consumir el token.

**El ID token puede tener información adicional sobre el usuario, como su dirección de correo electrónico, foto,
cumpleaños, etc.**

**Por último, quizá lo más importante**: el `ID token está firmado por el emisor con su clave privada`. Esto le
garantiza el origen del token y le asegura que no ha sido manipulado. **Puedes verificar estas cosas utilizando la clave
pública del emisor.**

### ¿Qué se puede hacer con un ID token?

En primer lugar, demuestra que el usuario ha sido autenticado por una entidad en la que confías
**(el proveedor de OpenID)** y, por tanto, puedes confiar en las afirmaciones sobre su identidad.

Además, tu aplicación puede personalizar la experiencia del usuario utilizando las afirmaciones sobre el usuario
incluidas en el token de identificación. Por ejemplo, **puede mostrar su nombre en la interfaz de usuario**, o **mostrar
un mensaje de "mejores deseos" en su cumpleaños**. La parte divertida es que no necesitas hacer peticiones adicionales,
por lo que puedes obtener una pequeña ganancia en el rendimiento de tu aplicación.

### ¿Qué es un Access Token?

En el diagrama siguiente, una aplicación cliente quiere acceder a un recurso, por ejemplo, una API o cualquier otra cosa
que esté protegida contra el acceso no autorizado. Los otros dos elementos de ese diagrama son el usuario, que es el
propietario del recurso, y el servidor de autorización. En este escenario, **el token de acceso es el artefacto que
permite a la aplicación cliente acceder al recurso del usuario.** Es emitido por el servidor de autorización después de
autenticar con éxito al usuario y obtener su consentimiento.

![get-access-token.png](./assets/get-access-token.png)

**En el contexto de OAuth 2, el token de acceso permite a una aplicación cliente acceder a un recurso específico para
realizar acciones específicas en nombre del usuario.** Es lo que se conoce como un escenario de `autorización delegada`:
**el usuario delega en una aplicación cliente para que acceda a un recurso en su nombre.** Esto significa, por ejemplo,
que puedes autorizar a tu aplicación de LinkedIn a acceder a la API de Twitter en tu nombre para realizar publicaciones
cruzadas en ambas plataformas sociales. Ten en cuenta que sólo autorizas a LinkedIn a publicar tus posts en Twitter. No
le autorizas a borrarlas ni a cambiar los datos de tu perfil ni a hacer otras cosas. Esta limitación es muy importante
en un escenario de autorización delegada y se consigue a través de los ámbitos (scopes). **Los ámbitos son un mecanismo
que permite al usuario autorizar a una aplicación de terceros a realizar sólo operaciones específicas.**

Por supuesto, la API que recibe el token de acceso debe estar segura de que realmente se trata de un token válido
emitido por el servidor de autorización en el que confía y tomar decisiones de autorización basadas en la información
asociada al mismo. En otras palabras, **la API necesita utilizar de algún modo ese token para autorizar a la aplicación
cliente a realizar la operación deseada en el recurso.**

**La forma de utilizar el token de acceso para tomar decisiones de autorización depende de muchos factores: la
arquitectura general del sistema, el formato del token, etc.** Por ejemplo, un token de acceso puede ser una clave que
permita a la API recuperar la información necesaria de una base de datos compartida con el servidor de autorización, o
puede contener directamente la información necesaria en un formato codificado. Esto significa que la comprensión de cómo
recuperar la información necesaria para tomar decisiones de autorización es un acuerdo entre el servidor de autorización
y el servidor de recursos, es decir, la API.

### ¿Para qué NO sirve un ID token?

Uno de los **errores más comunes** que cometen los desarrolladores **con un ID token es utilizarlo para llamar a una
API.**

En un escenario de autorización delegada en el que un cliente externo quiere llamar a tu API, **no debes utilizar un
ID token para llamar a la API.**

Si su API acepta un ID token como token de autorización, está ignorando el destinatario indicado en el claim de
audiencia. **Este claim dice que está destinada a su aplicación cliente, no al servidor de recursos
(es decir, la API).**

En primer lugar, entre otras comprobaciones de validación, **su API no debería aceptar un token que no esté destinado
a ella. Si lo hace, su seguridad está en peligro.** De hecho, si a su API no le importa si un token está destinado a
ella, un token de identificación robado de cualquier aplicación cliente puede utilizarse para acceder a su API. Por
supuesto, **comprobar la audiencia es solo una de las comprobaciones que debe hacer su API para evitar accesos no
autorizados.**

Además, **tu ID token no tendrá ámbitos concedidos**. Como se dijo antes, los ámbitos permiten al usuario restringir las
operaciones que su aplicación cliente puede hacer en su nombre. **Esos ámbitos están asociados con el token de acceso
para que tu API sepa lo que la aplicación cliente puede hacer y lo que no.**

### ¿Para qué NO sirve un Access Token?

En cuanto al token de acceso, **fue concebido para demostrar que está autorizado a acceder a un recurso**, por ejemplo,
para llamar a una API.

Su aplicación cliente debe utilizarlo únicamente por este motivo. En otras palabras, **el token de acceso no debe ser
inspeccionado por la aplicación cliente. Está destinado al servidor de recursos, y su aplicación cliente debe tratar los
tokens de acceso como cadenas opacas, es decir, cadenas sin significado específico.** Incluso si conoces el formato del
token de acceso, no deberías intentar interpretar su contenido en tu aplicación cliente. Como se ha dicho, el formato
del token de acceso es un acuerdo entre el servidor de autorización y el servidor de recursos, y la aplicación cliente
no debe entrometerse. Piensa en lo que puede pasar si un día cambia el formato del token de acceso. Si tu código cliente
estaba inspeccionando ese token de acceso, ahora se romperá inesperadamente.

### Resumen rápido

Los `access tokens` se definen en `OAuth`, los `ID tokens` se definen en `OpenID Connect`.

Los `access tokens` son los que utiliza el cliente de OAuth para realizar solicitudes a una API. El `access token`
está destinado a ser leído y validado por la API. Un `ID token` contiene información sobre lo que ocurrió cuando
un usuario se autenticó, y está destinado a ser leído por el cliente OAuth. El `ID token` también puede contener
información sobre el usuario, como su nombre o dirección de correo electrónico, aunque esto no es un requisito de
un `ID token`.

- Los `ID tokens` están pensados para ser leídos por el cliente OAuth. Los `access tokens` están pensados para ser
  leídos por el servidor de recursos.
- Los `ID tokens` son JWTs. Los `access tokens` pueden ser JWTs pero también pueden ser una cadena aleatoria.
- Los `ID tokens` nunca deben enviarse a una API. Los `access tokens` nunca deben ser leídos por el cliente.

![id-token-vs-access-token.jpg](./assets/id-token-vs-access-token.jpg)

---

### Escenario SPA + API: ¿ID Token o Access Token para construir vista html según rol del usuario?

Esta sección corresponde a una duda que me surgió al leer el artículo
[ID Token and Access Token: What's the Difference?](https://auth0.com/blog/id-token-access-token-what-is-the-difference/?_gl=1*fpqqgl*_gcl_aw*R0NMLjE2OTYzNTIzMzkuQ2p3S0NBanc5LTZvQmhCYUVpd0FIdjFRdkZPcmpjWFktbmlwUk1LMUU4YU1fdjgzOXZpdFNsNmRaLUMya1pFOGpzc3dRTVBheERUclJCb0NRZDRRQXZEX0J3RQ..*_gcl_au*ODc4NzEwOTI5LjE2OTUwMTU3MjM.)
La duda fue: *Si estoy desarrollando una aplicación cliente como Angular (SPA) y además tengo mi servidor de
autorización y servidor de recursos, ¿cómo determino las vistas html a mostrar según el rol del usuario?, ¿uso el ID
Token o Access Token para determinar los roles y así mostrar la vista html?*

La [respuesta obtenida por el autor del post andrea.chiarelli](https://community.auth0.com/t/id-token-and-access-token-what-is-the-difference/70028/36?u=magadiflo),
fue:

> En un escenario SPA + API, **los recursos del usuario (los recursos que debe proteger) viven del lado de la API**.
> Tus decisiones de autorización deben tomarse en ese lado. Por lo tanto, tu `Access Token` debe contener la información
> relevante para tus decisiones de autorización.
>
> **En el lado SPA**, no tomas decisiones de autorización reales. Solo gestionas la interfaz de usuario de tu aplicación
> para proporcionar una buena experiencia de usuario. **Puedes decidir mostrar ciertas vistas a categorías específicas
> de usuarios basadas en roles u otra información**. En este caso, **puedes poner esta información** en tu `ID token`.
>
> Tenga en cuenta que cualquiera puede eludir los controles que usted hace en el lado del cliente. Los controles del
> lado del cliente están ahí por razones de gestión de la interfaz de usuario. **Estas comprobaciones también deben
> reflejarse en el lado del servidor, donde se realiza el verdadero control de acceso.**
>
> En resumen, **cualquier información extra que añadas al** `ID Token` **(como los roles) tiene el propósito de
> mejorar la experiencia del usuario**, no de hacer un verdadero control de acceso a los recursos del usuario.

Como conclusión personal, puedo decir que la respuesta que me dio está relacionado con la publicación del post
[ID Token and Access Token: What Is the Difference?](https://auth0.com/blog/id-token-access-token-what-is-the-difference/?_gl=1*fpqqgl*_gcl_aw*R0NMLjE2OTYzNTIzMzkuQ2p3S0NBanc5LTZvQmhCYUVpd0FIdjFRdkZPcmpjWFktbmlwUk1LMUU4YU1fdjgzOXZpdFNsNmRaLUMya1pFOGpzc3dRTVBheERUclJCb0NRZDRRQXZEX0J3RQ..*_gcl_au*ODc4NzEwOTI5LjE2OTUwMTU3MjM.),
donde se menciona que el `ID Token` está pensado para ser
leído por el `Cliente OAuth`, mientras que el `Access Token` está pensado para ser leído por el `Servidor de Recursos`.
