# OAuth 2 y OpenID Connect

---

- Este apartado `no es del libro Spring Security In Action 2020`, sino más bien un complemento que coloco como parte
  de la explicación de `¿qué es OAuth 2?` y además abarco el protocolo `OpenID Connect`. Para tratar estos temas
  utilizo como **referencia las documentaciones oficiales.**
- Hay un tutorial que hice del canal del `Luigi Code` donde utilizamos **Spring Boot 3 y Angular** para desarrollar
  estos temas. A continuación se muestran los repositorios de dichos proyectos:
    - [Servidor de Autorización](https://github.com/magadiflo/authorization-server.git)
    - [Servidor de Recursos](https://github.com/magadiflo/resource-server.git)
    - [Cliente OAuth 2](https://github.com/magadiflo/oauth2-client-angular.git)

---

## [¿Qué es OAuth 2?](https://oauth.net/2/)

`OAuth 2.0 es el protocolo estándar del sector para la autorización`. OAuth 2.0 se centra en la simplicidad del
desarrollador cliente a la vez que `proporciona flujos de autorización específicos` para aplicaciones web, aplicaciones
de escritorio, teléfonos móviles y dispositivos de salón.

## [OAuth Access Tokens](https://oauth.net/2/access-tokens/)

Un `token de acceso OAuth` es una cadena que el `cliente OAuth` utiliza para
`realizar peticiones al servidor de recursos`.

Los tokens de acceso no tienen que estar en ningún formato en particular, y en la práctica, varios servidores OAuth han
elegido muchos formatos diferentes para sus tokens de acceso.

Los tokens de acceso pueden ser  `"bearer tokens"` o `"sender-constrained"`.

Hay una serie de propiedades de los tokens de acceso que son fundamentales para el modelo de seguridad de OAuth:

- Los tokens de acceso no deben ser leídos o interpretados por el cliente OAuth. El cliente OAuth no es el destinatario
  del token.
- Los tokens de acceso no transmiten la identidad del usuario ni ninguna otra información sobre el usuario al cliente
  OAuth.
- Los tokens de acceso sólo deben utilizarse para realizar solicitudes al servidor de recursos. Además, los tokens de
  identificación `(ID Tokens)` no deben utilizarse para realizar solicitudes al servidor de recursos.

## [ID Tokens vs Access Tokens](https://oauth.net/id-tokens-vs-access-tokens/)

Los `access tokens` se definen en `OAuth`, los `ID tokens` se definen en `OpenID Connect`.

Los `access tokens` son los que utiliza el cliente de OAuth para realizar solicitudes a una API. El `access token`
está destinado a ser leído y validado por la API. Un `ID token` contiene información sobre lo que ocurrió cuando
un usuario se autenticó, y está destinado a ser leído por el cliente OAuth. El `ID token` también puede contener
información sobre el usuario, como su nombre o dirección de correo electrónico, aunque esto no es un requisito de
un `ID token`.

- Los `ID tokens` están pensados para ser leídos por el cliente OAuth. Los `access tokens` están pensados para ser
  leídos por el servidor de recursos.
- Los `ID tokens` son JWTs. Los `access tokens` pueden ser JWTs pero también pueden ser una cadena aleatoria.
- Los `ID tokens` nunca deben enviarse a una API. Los `access tokens` nunca deben ser leídos por el cliente.

## [OAuth Refresh Tokens](https://oauth.net/2/refresh-tokens/)

Un `OAuth Refresh Token` es una cadena que el `cliente OAuth` puede utilizar para obtener un nuevo `access token` sin
la interacción del usuario.

Un token de actualización no debe permitir al cliente obtener ningún acceso más allá del alcance de la concesión
original. El token de actualización existe para permitir a los servidores de autorización utilizar tiempos de vida
cortos para los tokens de acceso sin necesidad de involucrar al usuario cuando el token expira.

## [OAuth Scopes](https://oauth.net/2/scope/)

`El ámbito (scope) es un mecanismo de OAuth 2.0 para limitar el acceso de una aplicación a la cuenta de un usuario`. Una
aplicación puede solicitar uno o más ámbitos, esta información se presenta al usuario en
la `pantalla de consentimiento`, y el access token emitido a la aplicación se limitará a los ámbitos concedidos.

OAuth no define ningún valor concreto para los ámbitos, ya que depende en gran medida de la arquitectura y las
necesidades internas del servicio.

**Ejemplos de ámbitos en servicios populares:**

- `GitHub`:  read:user, user:email, user:follow, etc.
- `Google`: openid, https://www.googleapis.com/auth/userinfo.profile, https://www.googleapis.com/auth/userinfo.email,
  etc.
- `slack`: admin.users:write, emoji:read, files:read, files:write:user, etc.

## [OAuth Grant Types](https://oauth.net/2/grant-types/)

El marco OAuth especifica varios tipos de concesión para diferentes casos de uso, así como un marco para crear nuevos
tipos de concesión.

A continuación se enumeran los tipos de concesión de OAuth más comunes:

- Authorization Code
- PKCE
- Client Credentials
- Device Code
- Refresh Token

A continuación se enumeran los tipos de concesión que en la actualidad ya son `legacy`:

- Implicit Flow
- Password Grant

---

## [OAuth 2.0 Authorization Code Grant](https://oauth.net/2/grant-types/authorization-code/)

El tipo de concesión de código de autorización es **utilizado por clientes confidenciales y públicos** para intercambiar
un `código de autorización` por un `access token`.

Después de que el usuario vuelva al cliente a través de la URL de redirección, la aplicación obtendrá el código de
autorización de la URL y lo utilizará para solicitar un token de acceso.

`Se recomienda que todos los clientes utilicen también la extensión PKCE con este flujo para proporcionar una mayor
seguridad.`

### [El flujo del código de autorización](https://developer.okta.com/blog/2018/04/10/oauth-authorization-code-grant-type)

El tipo de concesión Código de autorización es utilizado por aplicaciones web y móviles. Se diferencia de la mayoría de
los otros tipos de concesión en que primero requiere que la aplicación inicie un navegador para comenzar el flujo.

A grandes rasgos, el flujo consta de los siguientes pasos:

- La aplicación abre un navegador para enviar al usuario al servidor OAuth.
- El usuario ve la solicitud de autorización y aprueba la petición de la aplicación.
- El usuario es redirigido de vuelta a la aplicación con un código de autorización en la cadena de consulta.
- La aplicación intercambia el código de autorización por un token de acceso.

### 1° Paso: Obtener Código de Autorización

OAuth consiste en permitir a los usuarios conceder un acceso limitado a las aplicaciones. La aplicación primero tiene
que decidir qué permisos está solicitando, y luego enviar al usuario a un navegador para obtener su permiso. **Para
comenzar el flujo de autorización**, la aplicación construye una URL como la siguiente y abre un navegador a esa URL:

````
https://authorization-server.com/auth
 ?response_type=code
 &client_id=29352915982374239857
 &redirect_uri=https%3A%2F%2Fexample-app.com%2Fcallback
 &scope=create+delete
 &state=xcoiv98y2kd22vusuye3kch
````

A continuación se explica cada parámetro de consulta:

- `response_type=code`, indica al servidor de autorización que la aplicación está iniciando el flujo de código de
  autorización.
- `client_id`, el identificador público de la aplicación, obtenido cuando el desarrollador registró la aplicación por
  primera vez.
- `redirect_uri`, indica al servidor de autorización a dónde debe enviar al usuario después de aprobar la solicitud.
- `scope`, una o más cadenas separadas por espacios que indican qué permisos solicita la aplicación. La API de OAuth
  específica que utilices definirá los ámbitos que admite.
- `state`, la aplicación genera una cadena aleatoria y la incluye en la solicitud. A continuación, debe comprobar que
  se devuelve el mismo valor después de que el usuario autorice la aplicación. Esto se utiliza para prevenir ataques
  CSRF.

Cuando el usuario visite esta URL, el servidor de autorización le preguntará si desea autorizar la solicitud de esta
aplicación:

![authorization-code-open-id-connect](./assets/authorization-code-open-id-connect.png)

Si el usuario aprueba la solicitud `(clic en Allow)`, el servidor de autorización redirigirá el navegador de vuelta a la
`redirect_uri` especificada por la aplicación, `añadiendo un código` y un `estado` a la cadena de consulta.

Por ejemplo, el usuario será redirigido a una URL como la siguiente:

````
https://example-app.com/redirect
 ?code=g0ZGZmNjVmOWIjNTk2NTk4ZTYyZGI3
 &state=xcoiv98y2kd22vusuye3kch
````

- El `code` es el código de autorización generado por el servidor de autorización. Este código dura relativamente poco,
  normalmente entre 1 y 10 minutos dependiendo del servicio OAuth. `[Además, el código es de 1 solo uso].`
- El valor del `state` será el mismo que la aplicación estableció inicialmente en la solicitud. Se espera que la
  aplicación compruebe que el estado en la redirección coincide con el estado que estableció originalmente.
  **Esto protege contra CSRF y otros ataques relacionados.**

### 2° Paso: Intercambiar el Código de Autorización por un Access Token

Estamos a punto de terminar el flujo. Ahora que `la aplicación tiene el código de autorización, puede usarlo para
obtener un token de acceso`.

La aplicación realiza una `solicitud POST` al endpoint de token del servicio con los siguientes parámetros:

- `grant_type=authorization_code`, esto indica al endpoint del token que la aplicación está utilizando el tipo de
  concesión Authorization Code.
- `code`, la aplicación incluye el código de autorización que se le dio en la redirección.
- `redirect_uri`, el mismo URI de redirección que se utilizó al solicitar el código. Algunas API no requieren este
  parámetro, por lo que deberá consultar la documentación de la API concreta a la que esté accediendo.
- `client_id`, ID de cliente de la aplicación.
- `client_secret`, el secreto de cliente de la aplicación. Esto garantiza que la solicitud para obtener el token de
  acceso se realice únicamente desde la aplicación, y no desde un posible atacante que pueda haber interceptado el
  código de autorización.

El endpoint del token verificará todos los parámetros de la solicitud, asegurándose de que el código no ha caducado y
de que el ID de cliente y el secreto coinciden. Si todo es correcto, generará un token de acceso y lo devolverá en la
respuesta:

````
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3",
  "token_type":"bearer",
  "expires_in":3600,
  "refresh_token":"IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk",
  "scope":"create delete"
}
````

El flujo del código de autorización está completo. La aplicación tiene ahora un `access token` que puede utilizar
cuando haga peticiones a la API.

**NOTA**

> Si estás utilizando el flujo de Código de Autorización en una aplicación móvil, o cualquier otro tipo de aplicación
> que no pueda almacenar un secreto de cliente, entonces también deberías utilizar la `extensión PKCE`, que proporciona
> protecciones contra otros ataques en los que el código de autorización puede ser interceptado.

## [PKCE (Proof Key for Code Exchange)](https://oauth.net/2/pkce/)

`Proof Key for Code Exchange o Clave de prueba para el intercambio de código (abreviado PKCE, pronunciado "pixie")`
es una `extensión` del flujo de `código de autorización` para **prevenir ataques CSRF y de inyección de código
de autorización**.

La técnica consiste en que **el cliente cree primero un secreto en cada solicitud de autorización, y luego vuelva a
utilizar ese secreto cuando intercambie el código de autorización por un token de acceso**. De esta forma, si
el código es interceptado, no será útil, ya que la solicitud del token se basa en el secreto inicial.

PKCE no es una forma de autenticación de cliente, y `PKCE no es un reemplazo para un secreto de cliente` u otra
autenticación de cliente. `PKCE se recomienda incluso si un cliente está utilizando un secreto de cliente` u otra
forma de autenticación de cliente como private_key_jwt.

**Nota:** Dado que PKCE no sustituye a la autenticación de clientes, no permite tratar a un cliente público como cliente
confidencial.

PKCE se diseñó originalmente para proteger el flujo del `código de autorización` en aplicaciones móviles, y **más
tarde se recomendó su uso también en aplicaciones de una sola página**. En años posteriores, se reconoció que su
capacidad para evitar la inyección de código de autorización lo hace útil para todo tipo de cliente OAuth, incluso
aplicaciones que se ejecutan en un servidor web que utilizan un secreto de cliente. **Debido a su historia en el uso de
aplicaciones móviles y aplicaciones de una sola página, a veces se piensa erróneamente que PKCE es una alternativa a un
secreto de cliente**. Sin embargo,
`PKCE no sustituye a un secreto de cliente, y se recomienda PKCE incluso si un cliente utiliza un secreto de cliente`,
ya que las aplicaciones con un secreto de cliente siguen siendo susceptibles de sufrir ataques de inyección de código de
autorización.

La especificación completa está disponible como `RFC7636`. A continuación presentamos un resumen del protocolo:

### [1° Paso: Solicitar Authorization](https://www.oauth.com/oauth2-servers/pkce/authorization-request/)

Cuando la app nativa inicia la solicitud de autorización, en lugar de lanzar inmediatamente un navegador, **el cliente
crea primero** lo que se conoce como `"code verifier"`. Se trata de una cadena criptográficamente aleatoria que
utiliza los caracteres A-Z, a-z, 0-9 y los caracteres de puntuación -._~ (guión, punto, guión bajo y tilde), con una
longitud de entre 43 y 128 caracteres.

Una vez que la aplicación ha generado el `code verifier`, lo utiliza para derivar el `code challenge`.
Para los dispositivos que pueden realizar un `hash SHA256`, el `code challenge` es una cadena en `Base64-URL-encoded`
del hash `SHA256` del `code verifier`. Los clientes que no pueden realizar un hash SHA256 pueden utilizar como
`challenge` la cadena sin formato del `code verifier`, aunque esto ofrece menos ventajas de seguridad, por lo que sólo
debe utilizarse si es absolutamente necesario.

`Base64-URL-encoded` es una variación menor del típico método de codificación Base64. Comienza con el mismo método de
`Base64-encoding` disponible en la mayoría de los lenguajes de programación, pero en su lugar utiliza caracteres
`URL-safe` (url seguro). Puedes implementar un método `Base64-URL-encoding` tomando un `Base64-encoded` y
realizando las siguientes modificaciones en la cadena:  Toma la cadena `Base64-encoded` y `cambia + por -`, y
`/ por _`, luego `elimina el signo igual (=) del final`.

````javascript
function base64_urlencode(str) {
  return btoa(String.fromCharCode.apply(null, 
    new Uint8Array(str)))
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=+$/, '');
}
````

Ahora que el cliente tiene un `code challenge` (desafío de código), incluye eso y un parámetro que indica qué método se
utilizó para generar el desafío `(plain o S256)` junto con los parámetros estándar de la solicitud de autorización.
Esto significa que **una solicitud de autorización completa incluirá los siguientes parámetros**:

- `response_type=code`, le dice al servidor de autorización que el cliente espera un **código de autorización**. El
  cliente necesita el código para obtener un access token.
- `client_id`, el ID de cliente que recibió cuando creó la aplicación por primera vez.
- `redirect_uri`, indica la URL a la que debe volver el usuario una vez completada la autorización, como
  **org.example.app://redirect**.
- `state=1234zyx`, una cadena aleatoria generada por tu aplicación, que verificarás más tarde.
- `code_challenge=XXXXXXXXX`, el desafío de código generado como se ha descrito anteriormente.
- `code_challenge_method=S256`, ya sea plain o S256, dependiendo de si el reto es la cadena de verificación plain o el
  hash SHA256 de la cadena.

El servidor de autorización debe reconocer el parámetro `code_challenge` en la solicitud, y **asociarlo con el
código de autorización que genera**. Puede almacenarlo en la base de datos junto con el código de autorización o,
si utiliza códigos de autorización autocodificados, puede incluirlo en el propio código.
[(Véase La respuesta de autorización para más detalles)](https://www.oauth.com/oauth2-servers/authorization/the-authorization-response/)
El servidor devuelve el **código de autorización** de forma normal y **no incluye el challenge** en los datos devueltos.

**Respuesta de error**

**El servidor de autorización puede requerir que los clientes públicos utilicen la extensión PKCE**. Esta es realmente
la única manera de permitir que **las aplicaciones nativas tengan un flujo de autorización seguro sin utilizar el
secreto del cliente**, especialmente sin la seguridad de redirección URI que está disponible con los clientes basados en
web. Dado que el servidor de autorización debe saber que un ID de cliente específico corresponde a un cliente público,
puede denegar las solicitudes de autorización de clientes públicos que no contengan un `code challenge`.

Si el servidor de autorización requiere que los clientes públicos utilicen PKCE, y a la solicitud de autorización le
falta el `code challenge`, entonces el servidor debe devolver la respuesta de error con `error=invalid_request` y
`error_description` o `error_uri` deben explicar la naturaleza del error.

### [2° Paso: Intercambio Authorization Code](https://www.oauth.com/oauth2-servers/pkce/authorization-code-exchange/)

A continuación, la aplicación intercambiará el código de autorización por un token de acceso. Además de los parámetros
definidos en la solicitud de código de autorización, el cliente también enviará el parámetro `code_verifier`.

Una solicitud de token de acceso completa incluirá los siguientes parámetros:

- `grant_type=authorization_code`, indica el tipo de concesión de esta solicitud de token.
- `code`, el cliente enviará el código de autorización que obtuvo en la redirección.
- `redirect_uri`, la URL de redirección que se utilizó en la solicitud de autorización inicial.
- `client_id`, el ID de la aplicación cliente registrado.
- `client_secret (opcional)`, el secreto de la aplicación cliente registrada si se emitió un secreto.
- `code_verifier`, el verificador de código para la solicitud PKCE, que la aplicación generó originalmente antes de la
  solicitud de autorización.

Dado que el `code_challenge` y el `code_challenge_method` se asociaron inicialmente al código de autorización, el
servidor ya debería saber qué método utilizar para verificar el `code_verifier`.

Si el método es `plain`, el servidor de autorización sólo tiene que comprobar que el `code_verifier` proporcionado
coincide con la cadena esperada del `code_challenge`. Si el método es S256, entonces el servidor de autorización debe
tomar el `code_verifier` proporcionado y transformarlo utilizando el mismo método hash, y luego compararlo con la
cadena `code_challenge` almacenada.

Si el verificador coincide con el valor esperado, entonces el servidor puede continuar normalmente, emitiendo un
`acess_token` y respondiendo apropiadamente. Si hay un problema, entonces el servidor responde con un
error `invalid_grant`.

La extensión PKCE no añade ninguna respuesta nueva, por lo que los clientes siempre pueden utilizar la extensión PKCE
aunque un servidor de autorización no la admita.

### Generadores de código PKCE en línea

- [PKCE Code Generator](https://developer.pingidentity.com/en/tools/pkce-code-generator.html)
  (developer.pingidentity.com)
- [OAuth 2.0 `<debugger/>` Test OAuth 2.0 requests and debug responses](https://oauthdebugger.com/debug)
  (oauthdebugger.com)

En la imagen siguiente muestro la página de `oauthdebugger.com`, página que utilicé en el tutorial de `Luigi Code` cuyas
referencias coloqué al inicio de este README.

![pkce-code-generator](./assets/pkce-code-generator.png)

Centremos nuestra atención en los siguientes valores:

- `code_verifier`: RLVleJE1jVStvGEHgTseCob5OXrSCqLtmZJi7fj5kZ6
- `code_challenge`: SGnpsFzi5SDzVXmIUHIaLa-hA6uNoIcG_6G_NwH4kZ0
- `code_challenge_method`: S256

Cuando realizamos el `1° Paso: Solicitar Authorization` enviamos el `code_challenge` junto con el
`code_challenge_method`, estos valores se almacenan en el Servidor de Autorización y se asocian al Código de
Autorización retornado.

Cuando realizamos el `2° Paso: Intercambio Authorization Code` enviamos el `code_verifier` (obviamente otros valores
más, pero ahora estamos centrándonos en la extensión PKCE) y será el servidor de autorización quien a partir de ese
`code_verifier` y el método `code_challenge_method` almacenado inicialmente, genere un nuevo `code_challenge` y al final
compare el nuevo `code_challenge` con el `code_challenge` almacenado en el primer paso del flujo.

A continuación veamos la siguiente imagen donde vemos que **a partir de un code_verifier podemos generar
un code_challenge, pero no al revés**, para eso nos apoyaremos de una web en línea:

![sha-256](./assets/sha-256.png)

Entonces, que pasa si alguien obtiene el `authorization code` otorgado en el primer paso del flujo, pues no podrá
solicitar un `access token`, ya que necesita el `code_verifier` y quien tiene el `code_verifier` es el cliente original
quien inició el proceso de autorización.

Ahora, en la imagen se muestra el código generado en base64 quizá algo distinto (con el =, +, /), pero como se
mencionó en el paso `1° Paso: Solicitar Authorization` el Base64 encoded generado debe ser tratado para convertirlo
en un `Base64-URL-encoded`.

### [¿Cuál es la diferencia entre clientes confidenciales y públicos?](https://www.youtube.com/watch?v=5cQNwifDq1U)

En el protocolo OAuth 2 tenemos estas equivalencias:

- **Client** = Application
- **Resource Owner**  = User

Ahora, **¿qué significa confidencial clients y public clients?**, esto hace referencia si las aplicaciones tienen o no
la capacidad de mantener un `secret`. Veamos más detalles:

- `Confidential clients`: **son aplicaciones que pueden guardar un secret**. Por ejemplo: aplicaciones que
  se ejecutan en el lado del servidor `(backend)` o cualquier lugar donde se puedan definir variables y entradas de
  configuración en el entorno del lado del servidor, los secrets permanecerán allí y no serán visibles para los usuarios
  de la aplicación (client). En definitiva, son **clientes confidenciales** aquellas aplicaciones que son construidas
  usando un lenguaje del lado del servidor, tales como: `Java, PHP, .Net, etc`.
- `Public clients`: **son aplicaciones que NO PUEDEN guardar un secret**. Por ejemplo: una aplicación de JavaScript como
  un SPA usando Angular, pues todo el código fuente de la aplicación se descarga en el navegador. Otro ejemplo son
  las aplicaciones móviles, dispositivos integrados, internet de las cosas o incluso Apple TV.

Por lo tanto, ahora tenemos un problema, pues **los public clients no pueden usar el secreto en el flujo del tipo de
concesión de Código de Autorización** `¿Qué hacer?`.

Lo que haremos será que cuando la aplicación esté lista para iniciar un flujo OAuth, en realidad genera un secreto sobre
la marcha para ese intercambio en particular. Usará ese secreto cuando inicia el flujo de OAuth y luego nuevamente el
servidor OAuth requerirá ese secreto cuando se envíe el código de autorización intercambiando por el access token,
`esta técnica se llama PKCE`.

Los clientes públicos usan PKCE en lugar de un secreto de cliente.

## [OAuth 2.0 Client Credentials Grant](https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/)

La concesión de credenciales de cliente se usa cuando las aplicaciones solicitan un token de acceso para acceder a sus
propios recursos, no en nombre de un usuario.

## [OAuth 2.0 Refresh Token](https://www.oauth.com/oauth2-servers/access-tokens/refreshing-access-tokens/)

El tipo de concesión Refresh Token es utilizado por los clientes para intercambiar un refresh token por un token de
acceso cuando el token de acceso ha caducado.

Esto permite a los clientes seguir disponiendo de un token de acceso válido sin necesidad de interactuar con el usuario.

---

## [(LEGACY) OAuth 2.0 Implicit Grant](https://oauth.net/2/grant-types/implicit/)

El flujo implícito **era un flujo OAuth simplificado recomendado anteriormente para aplicaciones nativas y aplicaciones
JavaScript** en las que **el token de acceso se devolvía inmediatamente sin un paso adicional de intercambio de código
de autorización.**

**No se recomienda utilizar el flujo implícito** (y algunos servidores prohíben este flujo por completo) debido a los
riesgos inherentes de devolver tokens de acceso en una redirección HTTP sin ninguna confirmación de que ha sido recibido
por el cliente.

`Los clientes públicos, como las aplicaciones nativas y las aplicaciones JavaScript, deben utilizar ahora el flujo de
código de autorización con la extensión PKCE.`

El documento OAuth 2.0 Security Best Current Practice recomienda no utilizar el flujo Implicit en su totalidad, y OAuth
2.0 for Browser-Based Apps describe la técnica de utilizar el flujo de código de autorización con PKCE en su lugar.

## [(LEGACY) OAuth 2.0 Password Grant](https://oauth.net/2/grant-types/password/)

El tipo de concesión Contraseña es una forma heredada de intercambiar las credenciales de un usuario por un token de
acceso. Dado que la aplicación cliente tiene que recopilar la contraseña del usuario y enviarla al servidor de
autorización, no se recomienda seguir utilizando esta concesión.

Este flujo no proporciona ningún mecanismo para cosas como la autenticación multifactor o cuentas delegadas, por lo que
es bastante limitante en la práctica.

La última práctica recomendada de seguridad de **OAuth 2.0 prohíbe por completo la concesión de contraseña**, y
**la concesión no está definida en OAuth 2.1**.

---

## [¿Qué es OpenID Connect?](https://auth0.com/es/intro-to-iam/what-is-openid-connect-oidc)

`OpenID Connect u OIDC` es un protocolo de identidad que utiliza los mecanismos de autorización y autenticación de
OAuth 2.0.

`OpenID Connect es un protocolo de autenticación interoperable basado en el marco de especificaciones OAuth 2.0`.
Simplifica la forma de verificar la identidad de los usuarios basándose en la autenticación realizada por
un servidor de autorización y de obtener información sobre el perfil del usuario de forma interoperable y similar a
REST. ([Fuente: OpenID](https://openid.net/developers/how-connect-works/))

OIDC fue desarrollado por la Fundación OpenID, que incluye empresas como Google y Microsoft. Mientras que OAuth 2.0 es
un protocolo de autorización, `OIDC es un protocolo de autenticación de identidad y puede utilizarse para verificar la
identidad de un usuario ante un servicio de cliente`, también llamado **Parte de confianza**. Además, las declaraciones
de los usuarios, por ejemplo, el nombre, la dirección de correo electrónico, etc., también pueden ser compartidas a
petición.

Una amplia variedad de clientes pueden utilizar OpenID Connect (OIDC) para identificar a los usuarios, desde
aplicaciones de una sola página (SPA) hasta aplicaciones nativas y móviles. También puede utilizarse para el inicio de
sesión único (SSO) entre aplicaciones. OIDC utiliza JSON Web Tokens (JWT), flujos HTTP y evita compartir las
credenciales del usuario con los servicios.

## ¿Cómo encaja OpenID Connect con OAuth 2?

OIDC utiliza OAuth 2.0 como protocolo subyacente. Las principales extensiones son un valor del ámbito especial
`(“openid”)`, el uso de un token adicional (el `Token de ID`, que encapsula las reclamaciones de identidad en
formato JSON), y el `énfasis en la autenticación en lugar de la autorización`. Además, en OIDC, el término `“flujo”`
se utiliza en lugar de `“concesión”` de OAuth2

## Principios y definiciones de OpenID Connect

- El `proveedor de OIDC` **(generalmente llamado proveedor de OpenID o proveedor de identidad)** `realiza la
  autenticación del usuario`, el consentimiento del usuario y la emisión de tokens.
- `Parte de confianza (RP)`, puede ser, por ejemplo, **una aplicación web**, pero también una aplicación JavaScript o
  una aplicación móvil.

`Al estar construido sobre OAuth 2.0, OpenID Connect utiliza tokens` para proporcionar una capa de identidad simple
integrada con el marco de autorización subyacente. Esta integración implica el uso de los siguientes tipos de token:

- `Token de ID`, específicamente para OIDC, **el uso principal de este token en formato JWT es proporcionar información
  sobre el resultado de la operación de autenticación**. Mediante previa solicitud, puede proporcionar los datos de
  identidad que describen un perfil de usuario. Los datos sobre el resultado de la autenticación y la información del
  perfil del usuario se denominan reclamaciones `claims`. Las reivindicaciones del perfil del usuario pueden ser
  cualquier dato que sea pertinente para la Parte de confianza a efectos de identificación, como un ID persistente, una
  dirección de correo electrónico, un nombre, etc.
- `Token de accesso`, definido en OAuth2, este token (opcional) de corta duración proporciona acceso a recursos
  específicos del usuario, tal y como se define en los valores del ámbito en la solicitud al servidor de autorización.
- `Token de actualización`, según las especificaciones de OAuth2, este token suele ser de larga duración y puede usarse
  para obtener nuevos tokens de acceso.
