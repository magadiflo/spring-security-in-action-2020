# [Pág. 360] Capítulo 15 - OAuth 2: uso de JWT y firmas criptográficas

Aprendió en el capítulo 14 que el servidor de recursos necesita validar tokens emitidos por el servidor de autorización.
Y te dije tres maneras de hacer esto:

1. Usar llamadas directas entre el servidor de recursos y el servidor de autorizaciones, que implementamos en la sección
   14.2.
2. Usar una base de datos compartida para almacenar los tokens, que implementamos en la sección 14.3.
3. **Uso de firmas criptográficas**, de las que hablaremos en este capítulo.

El uso de firmas criptográficas para validar tokens tiene la ventaja de permitir que el servidor de recursos los valide
sin necesidad de llamar directamente al servidor de autorización y sin necesidad de una base de datos compartida. **Este
enfoque para implementar la validación de tokens se usa comúnmente en sistemas que implementan autenticación y
autorización con OAuth 2.** Por este motivo, debe conocer esta forma de implementar la validación de tokens.

## [Pág. 361] Usando tokens firmados con claves simétricas con JWT

**El enfoque más sencillo** para firmar tokens es **usar claves simétricas.** Con este enfoque, **utilizando la misma
clave,** puede **firmar un token y validar su firma.** El uso de **claves simétricas** para firmar tokens tiene la
ventaja de ser **más simple** que otros enfoques que discutiremos más adelante en este capítulo y también es **más
rápido.** Como verá, sin embargo, también tiene desventajas. No siempre puede compartir la clave utilizada para firmar
tokens con todas las aplicaciones involucradas en el proceso de autenticación.

## [Pág. 361] Usando JWTs

**Un JWT es una implementación de token.** Un jwt consta de **tres partes**: **el encabezado, el cuerpo y la firma.**
Los detalles en el encabezado y el cuerpo se representan con JSON y están codificados en Base64. La tercera parte es la
firma, generada mediante un algoritmo criptográfico que utiliza como entrada la cabecera y el cuerpo (figura 15.1). El
algoritmo criptográfico también implica la necesidad de una clave. La clave es como una contraseña. Alguien que tenga
una clave adecuada puede firmar un token o validar que una firma sea auténtica. Si la firma en un token es auténtica,
eso garantiza que nadie alteró el token después de haberlo firmado.

![figure-15-1](./assets/figure-15-1.png)

**Cuando se firma un JWT, también lo llamamos JWS (JSON Web Token Signed).** Por lo general, basta con aplicar un
algoritmo criptográfico para firmar un token, pero a veces puede optar por cifrarlo. Si se firma un token, puede ver
su contenido sin tener ninguna clave o contraseña. Pero incluso si un hacker ve el contenido del token, no puede
cambiar el contenido del token porque si lo hace, la firma se vuelve inválida (figura 15.2). Para ser válida,
una firma debe:

- Ser generado con la clave correcta.
- Hacer coincidir el contenido que se firmó.

![figure-15-2](./assets/figure-15-2.png)

**Si un token está encriptado, también lo llamamos JWE (JSON Web Token Encrypted).** No puede ver el contenido de un
token encriptado sin una clave válida.

## [Pág. 363] Implementación de un servidor de autorización para emitir JWT

**En esta sección, implementamos un servidor de autorización que emite JWT** a un cliente para su autorización.
**Aprendió** en el capítulo 14 **que el componente que administra los tokens es el TokenStore.** Lo que hacemos **en
esta sección** es usar una **implementación diferente de TokenStore** proporcionada por Spring Security. El nombre de la
implementación que usamos es **JwtTokenStore** y administra los JWT. También probamos el servidor de autorización en
esta sección. Más adelante, en la sección 15.1.3, implementaremos un servidor de recursos y tendremos un sistema
completo que usa JWT.

Puede implementar la validación de tokens con JWT de dos maneras:

- Si usamos la **misma clave para firmar el token y para verificar la firma, decimos que la clave es simétrica.**
- Si usamos **una clave para firmar el token** pero **otra diferente para verificar la firma**, decimos que **usamos un
  par de claves asimétricas.**

**En este ejemplo, implementamos la firma con una clave simétrica.** Este enfoque implica que tanto el servidor de
autorizaciones como el servidor de recursos conocen y utilizan la misma clave. El servidor de autorización firma el
token con la clave y el servidor de recursos valida la firma con la misma clave (figura 15.3).

![figure-15-3](./assets/figure-15-3.png)

El siguiente fragmento de código presenta las dependencias que debemos agregar. Estos son los mismos que usamos para el
servidor de autorización en los capítulos 13 y 14:

````xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.0.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.magadiflo.book.security</groupId>
    <artifactId>spring-security-in-action-2020</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>spring-security-in-action-2020</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
        <spring-cloud.version>Hoxton.SR1</spring-cloud.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-oauth2</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
````

**Configuramos un JwtTokenStore** de la misma manera que lo hicimos en el capítulo 14 para el JdbcTokenStore. Además,
**necesitamos definir un objeto de tipo JwtAccessTokenConverter.** Con JwtAccessTokenConverter, **configuramos cómo el
servidor de autorización valida los tokens;** en nuestro caso, **utilizando una clave simétrica.** La siguiente lista le
muestra cómo configurar JwtTokenStore en la clase de configuración.

````java

@EnableAuthorizationServer
@Configuration
public class AuthServerConfig extends AuthorizationServerConfigurerAdapter {
    @Value("${jwt.key}")
    private String jwtKey; // Obtiene el valor de la clave simétrica del archivo application.properties
    @Autowired
    private AuthenticationManager authenticationManager;

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.authenticationManager(this.authenticationManager)
                .tokenStore(this.tokenStore())                          // Configura el almacén de tokens y los 
                .accessTokenConverter(this.jwtAccessTokenConverter());  // objetos convertidores de tokens de acceso.
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient("client")
                .secret("secret")
                .authorizedGrantTypes("password", "refresh_token")
                .scopes("read");
    }

    @Bean
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey(this.jwtKey); // Establece el valor de la clave simétrica para el objeto convertidor de token de acceso
        return converter;
    }

    @Bean
    public TokenStore tokenStore() { // Crea una tienda de tokens con un convertidor de tokens de acceso asociado.
        return new JwtTokenStore(this.jwtAccessTokenConverter());
    }
}
````

Guardé el valor de la clave simétrica para este ejemplo en el archivo application.properties, como muestra el siguiente
fragmento de código. Sin embargo, no olvide que la clave de firma es información confidencial y debe almacenarla en una
bóveda de secretos en un escenario del mundo real.

````properties
jwt.key=ymLTU8rq83j4fmJZj60wh4OrMNuntIj4fmJ
````

Recuerde de nuestros ejemplos anteriores con el servidor de autorización en los capítulos 13 y 14 que para cada servidor
de autorización, también definimos un UserDetailsServer y PasswordEncoder. El listado 15.2 le recuerda cómo configurar
estos componentes para el servidor de autorización. Para que las explicaciones sean breves, no repetiré la misma lista
para todos los siguientes ejemplos en este capítulo.

````java

@Configuration
public class UserManagementConfig {
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails userDetails = User.builder()
                .username("admin")
                .password("12345")
                .authorities("read")
                .build();

        InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
        inMemoryUserDetailsManager.createUser(userDetails);

        return inMemoryUserDetailsManager;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }
}
````

````java

@Configuration
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}
````

Ahora podemos **iniciar el servidor de autorización y llamar al punto final /oauth/token para obtener un token de
acceso.** El siguiente fragmento de código muestra el comando cURL para llamar al punto final /oauth/token:

````bash
curl -v -X POST -u client:secret -d "grant_type=password&username=admin&password=12345&scope=read" http://localhost:8080/oauth/token

--- Response ---
< HTTP/1.1 200
<
{
  "access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2ODY4MDU3NjgsInVzZXJfbmFtZSI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOlsicmVhZCJdLCJqdGkiOiI4YjdkYjJiYy03NTZlLTRjNjYtYTIwNi1jY2UwZWYyOTEyYjciLCJjbGllbnRfaWQiOiJjbGllbnQiLCJzY29wZSI6WyJyZWFkIl19.mOhgpAlS_9SxG7ofbq556M-2PXRvBYSEnXlIAcKtN-U",
  "token_type":"bearer",
  "refresh_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInNjb3BlIjpbInJlYWQiXSwiYXRpIjoiOGI3ZGIyYmMtNzU2ZS00YzY2LWEyMDYtY2NlMGVmMjkxMmI3IiwiZXhwIjoxNjg5MzU0NTY4LCJhdXRob3JpdGllcyI6WyJyZWFkIl0sImp0aSI6IjU3Njc5M2FmLTk2MTEtNGUyZi04OWFmLTA1N2M5MDhjYmE2NiIsImNsaWVudF9pZCI6ImNsaWVudCJ9.OJRDrG9jAu84kDoo_BE7awPHGAhSlMGKbLbgXpRO8co",
  "expires_in":43199,
  "scope":"read",
  "jti":"8b7db2bc-756e-4c66-a206-cce0ef2912b7"
}
````

Puede observar en la respuesta que tanto los tokens de acceso como los de actualización ahora son JWT. Para poder ver
la forma decodificada(JSON) del access token o refresh token puede ir a la página [jwt.io](https://jwt.io/) y pegar los
jwt, verá el contenido de los JWT.

**NOTA**

La implementación de este servidor de autorización estará subido a este repositorio
[spring-security-in-action-2020-cap-15-jwt-authorization-server](https://github.com/magadiflo/spring-security-in-action-2020-cap-15-jwt-authorization-server.git)

## [Pág. 367] Implementando un servidor de recursos que usa JWT

En esta sección, **implementamos el servidor de recursos**, que utiliza la **clave simétrica** para validar los tokens
emitidos por el servidor de autorización que configuramos en la sección 15.1.2. Al final de esta sección, sabrá cómo
escribir un sistema OAuth 2 completo que use JWT firmados con claves simétricas.

````xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.0.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.magadiflo.book.security</groupId>
    <artifactId>spring-security-in-action-2020</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>spring-security-in-action-2020</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
        <spring-cloud.version>Hoxton.SR1</spring-cloud.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-oauth2</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
````

No agregué ninguna dependencia nueva a lo que ya usamos en los capítulos 13 y 14. Ahora, debido a que necesitamos un
punto final para asegurar, defino un controlador y un método para exponer un punto final simple que usamos para probar
el servidor de recursos. La siguiente lista define el controlador.

````java

@RestController
public class HelloController {
    @GetMapping("/hello")
    public String hello() {
        return "Hello!";
    }
}
````

Ahora que tenemos un punto final para asegurar, podemos declarar la clase de configuración donde configuramos el
TokenStore. **Configuraremos el TokenStore para el servidor de recursos como lo hacemos para el servidor de
autorización.** El aspecto más importante es **asegurarnos de que usamos el mismo valor para la clave.** El servidor
de recursos necesita la clave para validar la firma de un token. La siguiente lista define la clase de configuración
del servidor de recursos.

````java

@EnableResourceServer
@Configuration
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {
    @Value("${jwt.key") // Inyecta el valor de la clave desde el application.properties
    private String jwtKey;

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
        resources.tokenStore(this.tokenStore()); // Configura el tokenStore
    }

    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(this.jwtAccessTokenConverter()); // Declara el TokenStore y lo agrega al contexto de Spring
    }

    @Bean
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        //Crea un convertidor de token de acceso y establece la clave simétrica utilizada para validar las firmas de token
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey(this.jwtKey);
        return converter;
    }
}
````

No olvide establecer el valor de la clave en el archivo properties de la aplicación. Además, debido a que ejecuto el
servidor de autorización y el servidor de recursos localmente en la misma máquina, necesito configurar un puerto
diferente para esta aplicación.

````properties
server.port=9090
jwt.key=ymLTU8rq83j4fmJZj60wh4OrMNuntIj4fmJ
````

Una clave utilizada para el cifrado o la firma simétrica es solo una cadena aleatoria de bytes. Lo generas usando un
algoritmo para la aleatoriedad. En nuestro ejemplo, puede usar cualquier valor de cadena, digamos "abcde". **En un
escenario del mundo real**, es una buena idea utilizar un **valor generado aleatoriamente con una longitud**,
preferentemente, **superior a 258 bytes.**

Ahora podemos iniciar nuestro servidor de recursos y llamar al extremo /hello utilizando un JWT válido que obtuvo
anteriormente del servidor de autorización. Debe agregar el token al encabezado HTTP de autorización en la solicitud con
el prefijo "Bearer" en nuestro ejemplo. El siguiente fragmento de código le muestra cómo llamar al punto final usando
cURL:

````bash
curl -v -H "Authorization: bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2ODY4MDU3NjgsInVzZXJfbmFtZSI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOlsicmVhZCJdLCJqdGkiOiI4YjdkYjJiYy03NTZlLTRjNjYtYTIwNi1jY2UwZWYyOTEyYjciLCJjbGllbnRfaWQiOiJjbGllbnQiLCJzY29wZSI6WyJyZWFkIl19.mOhgpAlS_9SxG7ofbq556M-2PXRvBYSEnXlIAcKtN-U" http://localhost:9090/hello

--- Response ---
< HTTP/1.1 200
<
Hello!
````

Acaba de terminar de implementar un sistema que usa OAuth 2 con JWT como implementación de token. Como descubrió, Spring
Security facilita esta implementación. En esta sección, aprendió a usar una clave simétrica para firmar y validar
tokens.

**NOTA**

La implementación de este servidor de recursos estará subido a este repositorio
[spring-security-in-action-2020-cap-15-jwt-resource-server](https://github.com/magadiflo/spring-security-in-action-2020-cap-15-jwt-resource-server.git)

---

## [Pág. 370] Uso de tokens firmados con claves asimétricas con JWT

En esta sección, **implementamos un ejemplo de autenticación OAuth 2 donde el servidor de autorización y el servidor de
recursos usan un par de claves asimétricas para firmar y validar tokens.** A veces, tener solo una clave compartida por
el servidor de autorización y el servidor de recursos, como implementamos en la sección 15.1, no es factible. A menudo,
este escenario ocurre si el servidor de autorizaciones y el servidor de recursos no están desarrollados por la misma
organización. En este caso, decimos que el servidor de autorizaciones no "confía" en el servidor de recursos, por lo que
no desea que el servidor de autorizaciones comparta una clave con el servidor de recursos. Y, con claves simétricas, el
servidor de recursos tiene demasiado poder: la posibilidad no solo de validar tokens, sino también de firmarlos (figura
15.4)

![figure-15-4](./assets/figure-15-4.png)

**Nota**

> Mi regla general es que si necesita compartir la clave fuera de su sistema, no debería ser simétrica.

Cuando **no podemos asumir una relación confiable** entre el servidor de autorización y el servidor de recursos,
**usamos pares de claves asimétricas.** Por esta razón, necesita saber cómo implementar dicho sistema.

**¿Qué es un par de claves asimétricas y cómo funciona?** El concepto es bastante simple. Un par de claves asimétricas
tiene dos claves: una llamada **clave privada** y otra llamada **clave pública.** **El servidor de autorización usa la
clave privada para firmar tokens,** y alguien puede **firmar tokens solo usando la clave privada** (figura 15.5).

![figure-15-5](./assets/figure-15-5.png)

**La clave pública está vinculada a la clave privada**, y por eso la llamamos par. Pero la **clave pública solo se puede
usar para validar la firma.** ``Nadie puede firmar un token usando la clave pública`` (figura 15.6).

![figure-15-6](./assets/figure-15-6.png)

## [Pág. 372] Generando el par de claves

Necesitamos un par de claves para configurar el servidor de autorizaciones y el servidor de recursos que implementamos
en las secciones 15.2.2 y 15.2.3. Este es un par de claves asimétricas (lo que significa que tiene una parte privada que
usa el servidor de autorización para firmar un token y una parte pública que usa el servidor de recursos para validar la
firma).

Para generar el par de claves, uso **keytool y OpenSSL**, que son dos herramientas de línea de comandos fáciles de usar.
**Su JDK instala keytool**, por lo que probablemente ya lo tenga en su computadora. Para OpenSSL, debe descargarlo
de https://www.openssl.org/. **Si usa Git Bash, que viene con OpenSSL**, no necesita instalarlo por separado. Siempre
prefiero usar Git Bash para estas operaciones porque no requiere que instale estas herramientas por separado. Una vez
que tenga las herramientas, debe ejecutar dos comandos para:

- Generar una clave privada.
- Obtener la clave pública para la clave privada generada previamente.

### GENERANDO UNA CLAVE PRIVADA

**Para generar una clave privada**, ejecute el comando keytool como se muestra en el siguiente fragmento de código.
**Genera una clave privada en un archivo llamado ssia.jks**. También uso la contraseña "ssia123" para proteger la clave
privada y el alias "ssia" para darle un nombre a la clave. En el siguiente comando, puede ver el algoritmo utilizado
para generar la clave, RSA:

````bash
keytool -genkeypair -alias ssia -keyalg RSA -keypass ssia123 -keystore ssia.jks -storepass ssia123

--- Resultado ---
What is your first and last name?
  [Unknown]:
What is the name of your organizational unit?
  [Unknown]:
What is the name of your organization?
  [Unknown]:
What is the name of your City or Locality?
  [Unknown]:
What is the name of your State or Province?
  [Unknown]:
What is the two-letter country code for this unit?
  [Unknown]:
Is CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown correct?
  [no]:  yes

Generating 2,048 bit RSA key pair and self-signed certificate (SHA256withRSA) with a validity of 90 days
        for: CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown
````

Como resultado de la ejecución del comando anterior en el cmd, se genera un archivo llamado **ssia.jks** en la ruta
donde se ejecutó dicho comando, este archivo contiene la clave privada.

**NOTA**

> En mi caso, si bien es cierto sí se generó el archivo **ssia.jks**, e incluso a partir de él generé la clave
> pública, pero al momento de correr el servidor de autorización arrojaba errores, probé usando el cmd de windows,
> el bash de git, y el cmdr, pero seguía con lo mismo, es decir, los archivos que generaba al correr la aplicación
> me generaba errores, por lo que finalmente opté por usar el archivo expuesto en el repositorio remoto de este libro
> para colocarlo en el /resources de este proyecto. Así mismo, como se verá más abajo, utilicé la misma clave pública
> proporcionada por este libro.

### OBTENCIÓN DE LA CLAVE PÚBLICA

Para obtener la clave pública de la clave privada generada anteriormente, mediante el cmd nos posicionamos en la ruta
del archivo que generamos anteriormente y ejecutamos el comando keytool:

````bash
keytool -list -rfc --keystore ssia.jks | openssl x509 -inform pem -pubkey
````

Al generar la clave pública se le solicitará que ingrese la contraseña utilizada cuando se generó la clave privada;
en mi caso, ssia123. Luego, debe encontrar la clave pública y un certificado en la salida. **(Solo el valor de la clave
es esencial para nosotros en este ejemplo).** Esta clave debe tener un aspecto similar al siguiente fragmento de código:

````bash
--- Se solicita el password usado en la clave privada ---
Enter keystore password:  ssia123

-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAijLqDcBHwtnsBw+WFSzG
VkjtCbO6NwKlYjS2PxE114XWf9H2j0dWmBu7NK+lV/JqpiOi0GzaLYYf4XtCJxTQ
DD2CeDUKczcd+fpnppripN5jRzhASJpr+ndj8431iAG/rvXrmZt3jLD3v6nwLDxz
pJGmVWzcV/OBXQZkd1LHOK5LEG0YCQ0jAU3ON7OZAnFn/DMJyDCky994UtaAYyAJ
7mr7IO1uHQxsBg7SiQGpApgDEK3Ty8gaFuafnExsYD+aqua1Ese+pluYnQxuxkk2
Ycsp48qtUv1TWp+TH3kooTM6eKcnpSweaYDvHd/ucNg8UDNpIqynM1eS7KpffKQm
DwIDAQAB
-----END PUBLIC KEY-----
````

¡Eso es todo! Tenemos una clave privada que podemos usar para firmar JWT y una clave pública que podemos usar para
validar la firma. Ahora solo tenemos que configurarlos en nuestros servidores de autorización y recursos.

## [Pág. 373] Implementación de un servidor de autorización que utiliza claves privadas

En esta sección, configuramos el servidor de autorización para usar una clave privada para firmar JWT. Para esta
sección, usaremos las mismas dependencias en el archivo pom.xml que usamos para el servidor de autorización que
implementamos en la sección: **Usando tokens firmados con clave simétrica**. Ahora, para esta sección de claves
asimétricas, usaremos el proyecto de sección anterior, cuyo repositorio remoto es:
[spring-security-in-action-2020-cap-15-jwt-authorization-server](https://github.com/magadiflo/spring-security-in-action-2020-cap-15-jwt-authorization-server.git)
y crearemos una rama para trabajar en él: **features/servidor-autorizacion-jwt-asimetrica**.

Copio el archivo de clave privada, **ssia.jks**, en la carpeta de recursos de mi aplicación. Agrego la clave en la
carpeta de recursos porque es más fácil para mí leerla directamente desde el classpath. Sin embargo, no es obligatorio
estar en el classpath. En el archivo **application.properties, almaceno el nombre del archivo, el alias de la clave y la
contraseña que usé para proteger la clave privada cuando generé la contraseña**. Necesitamos estos detalles para
configurar JwtTokenStore. El siguiente fragmento de código muestra el contenido de mi archivo application.properties:

````properties
password=ssia123
privateKey=ssia.jks
alias=ssia
````

En comparación con las configuraciones que hicimos para que el servidor de autorizaciones use una clave simétrica, **lo
único que cambia es la definición del objeto JwtAccessTokenConverter.** Todavía usamos JwtTokenStore. Si recuerda,
usamos JwtAccessTokenConverter para configurar la clave simétrica en la sección 15.1. **Usamos el mismo objeto
JwtAccessTokenConverter para configurar la clave privada**. La siguiente lista muestra la clase de configuración del
servidor de autorizaciones.

````java

@EnableAuthorizationServer
@Configuration
public class AuthServerConfig extends AuthorizationServerConfigurerAdapter {
    @Value("${password}")
    private String password;

    @Value("${privateKey}")
    private String privateKey;

    @Value("${alias}")
    private String alias;
    @Autowired
    private AuthenticationManager authenticationManager;

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.authenticationManager(this.authenticationManager)
                .tokenStore(this.tokenStore())
                .accessTokenConverter(this.jwtAccessTokenConverter());
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient("client")
                .secret("secret")
                .authorizedGrantTypes("password", "refresh_token")
                .scopes("read");
    }

    @Bean
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        ClassPathResource pathResource = new ClassPathResource(this.privateKey);
        KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(pathResource, this.password.toCharArray());//Crea un objeto KeyStoreKeyFactory para leer el archivo de clave privada del classpath

        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setKeyPair(keyStoreKeyFactory.getKeyPair(this.alias));//Utiliza el objeto KeyStoreKeyFactory para recuperar el par de claves y establece el par de claves en el objeto JwtAccessTokenConverter

        return converter;
    }

    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(this.jwtAccessTokenConverter());
    }
}
````

Ahora puede iniciar el servidor de autorización y llamar al endpoint **/oauth/token para generar un nuevo token de
acceso.** Por supuesto, solo ve un JWT normal creado, pero **la diferencia ahora es que para validar su firma, debe usar
la clave pública en el par**. Por cierto, **no olvide que el token solo está firmado, no encriptado.** El siguiente
fragmento de código le muestra cómo llamar al endpoint **/oauth/token:**

````bash
curl -v -X POST -u client:secret -d "grant_type=password&username=admin&password=12345&scope=read" http://localhost:8080/oauth/token

--- Response ---
< HTTP/1.1 200
<
{ 
  "access_token":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2ODY4MzE2MzUsInVzZXJfbmFtZSI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOlsicmVhZCJdLCJqdGkiOiJmODViZjg4Yi04NTI1LTRhNzAtOTQ1Yy1mZTkzNmJiYThjYWUiLCJjbGllbnRfaWQiOiJjbGllbnQiLCJzY29wZSI6WyJyZWFkIl19.Nq45uOTQ4eLLy66yKlC-MxMtIan_PAuIt5-Mu9GM5DJdS_UisQorOxJCbnVqIsRUGBQzeKBGFJHWoMjFGPZ4I2b8B9pc9ZoXX2-BW_KdlMutFo-7By3xC7Kh7hVBiiis-p-4XNxZFAnWNyKXi8dm13SHh5f3BllCgbgiZv0onVonKp9fWh-ugWRd7Z81ptUxcW6bRIvkfoSK-Bdire9Seav7_7PXcbfvQOb8gOJ6UA1A1r2TreNnSCESHCgacCFYxPgUHAyC0BxZcBLSmaNtJqB56pEKqE-0C1m_3fHXziPsuZZZvwhnk-2FM5srvkEHVsESIAT03Kh8n6ShSw8QjA",
  "token_type":"bearer",
  "refresh_token":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInNjb3BlIjpbInJlYWQiXSwiYXRpIjoiZjg1YmY4OGItODUyNS00YTcwLTk0NWMtZmU5MzZiYmE4Y2FlIiwiZXhwIjoxNjg5MzgwNDM1LCJhdXRob3JpdGllcyI6WyJyZWFkIl0sImp0aSI6ImQ0MWNhM2JjLWVmYzktNDI0Yy1hMzc2LTIzZWNjYTc4NjhkNCIsImNsaWVudF9pZCI6ImNsaWVudCJ9.BYZDRM_kyTw2ZtKxHilfq8el2PyV_7rT6pf81xsX8S5gE9uYTEHPafl-aQXmqP7OMCZLG4mVNyGnDJXaZMCVDnMITow617OKm0UmcKu6B62DdijVTsbkJY0WRfskvEYuTOoSmVaptmh9K6DPkgi8kTofmF4YoUWh7H6XDrxwqbBDIPDTm2te225nbCAANw8aZI2XJCB5rZ3zR0pRSdlqfvaDGyxbvrXxvprlg8nc0HlY63955mkImWsZhC5Aw0kxN17gYiPQ6jAVPKPpBHU-fd1T0vBurSedl1oPKG1KNeS5vWoGq_YocDgnz50RJjqV_HY3z8v4JpzrfN_DHlvpcw",
  "expires_in":43199,
  "scope":"read",
  "jti":"f85bf88b-8525-4a70-945c-fe936bba8cae"
}
````
